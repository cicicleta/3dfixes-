// HUD graphics
// ---- Created with 3Dmigoto v0.6.109 on Thu Jul 11 01:15:36 2024
cbuffer cb3 : register(b3)
{
  float4 cb3[21];
}

cbuffer cb2 : register(b2)
{
  float4 cb2[4];
}

cbuffer cb1 : register(b1)
{
  float4 cb1[7];
}

cbuffer cb0 : register(b0)
{
  float4 cb0[7];
}




// 3Dmigoto declarations
#define cmp -
Texture1D<float4> IniParams : register(t120);
Texture2D<float4> StereoParams : register(t125);


void main(
  float4 v0 : POSITION0,
  float4 v1 : COLOR0,
  float2 v2 : TEXCOORD0,
  out float4 o0 : SV_POSITION0,
  out float4 o1 : COLOR0,
  out float2 o2 : TEXCOORD0,
  out float4 o3 : TEXCOORD1,
  out float4 o4 : TEXCOORD2)
{
  float4 r0,r1,r2;
  uint4 bitmask, uiDest;
  float4 fDest;

float4 stereo = StereoParams.Load(0);
float4 iniParams = IniParams.Load(0);
float separation = stereo.x; float convergence = stereo.y;

  r0.xyzw = cb2[1].xyzw * v0.yyyy;
  r0.xyzw = cb2[0].xyzw * v0.xxxx + r0.xyzw;
  r0.xyzw = cb2[2].xyzw * v0.zzzz + r0.xyzw;
  r0.xyzw = cb2[3].xyzw + r0.xyzw;
  r1.xyzw = cb3[18].xyzw * r0.yyyy;
  r1.xyzw = cb3[17].xyzw * r0.xxxx + r1.xyzw;
  r1.xyzw = cb3[19].xyzw * r0.zzzz + r1.xyzw;
  r0.xyzw = cb3[20].xyzw * r0.wwww + r1.xyzw;
  o0.xyzw = r0.xyzw;
  
// Can't really do this because it breaks graphic items and some parts like hands
// Move HUD to 20% depth 
// o0.x += 0.2 * separation * convergence;

  r0.xyz = v1.xyz * float3(0.265884995,0.265884995,0.265884995) + float3(0.736584008,0.736584008,0.736584008);
  r0.xyz = v1.xyz * r0.xyz + float3(-0.00980184041,-0.00980184041,-0.00980184041);
  r0.xyz = v1.xyz * r0.xyz + float3(0.00319697009,0.00319697009,0.00319697009);
  r1.xyz = v1.xyz * float3(0.0849710032,0.0849710032,0.0849710032) + float3(-0.000163029006,-0.000163029006,-0.000163029006);
  r2.xyz = cmp(v1.xyz < float3(0.0725490004,0.0725490004,0.0725490004));
  r0.xyz = r2.xyz ? r1.xyz : r0.xyz;
  r1.xyz = cb0[6].zzz ? r0.xyz : v1.xyz;
  r1.w = v1.w;
  o1.xyzw = cb0[2].xyzw * r1.xyzw;
  o2.xy = v2.xy * cb0[5].xy + cb0[5].zw;
  o3.xyzw = v0.xyzw;
  r0.xy = cb3[6].xy * cb1[6].yy;
  r0.xy = cb3[5].xy * cb1[6].xx + r0.xy;
  r0.xy = r0.ww / abs(r0.xy);
  r0.xy = cb0[6].xy * float2(0.25,0.25) + abs(r0.xy);
  o4.zw = float2(0.25,0.25) / r0.xy;
  r0.xyzw = max(float4(-2e+10,-2e+10,-2e+10,-2e+10), cb0[4].xyzw);
  r0.xyzw = min(float4(2e+10,2e+10,2e+10,2e+10), r0.xyzw);
  r0.xy = v0.xy * float2(2,2) + -r0.xy;
  o4.xy = r0.xy + -r0.zw;

// Determine if the HUD element is in the middle of the screen
float4 PositionNorm = normalize(o0);
// float crosshair = (PositionNorm.x > -0.35 && PositionNorm.x < 0.35 && PositionNorm.y > -0.56 && PositionNorm.y < 0.30);

bool crosshair = (PositionNorm.x > -0.01 && PositionNorm.x < 0.01 && PositionNorm.y > -0.01 && PositionNorm.y < 0.01);

// If it's the crosshair location, zero it out to hide it.
if (crosshair)
{
	// o0 = 0;
	o1 = float4(0,0,0,0);	// transparent black
}

  return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//   using 3Dmigoto v0.6.109 on Thu Jul 11 01:15:36 2024
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// POSITION                 0   xyzw        0     NONE   float   xyzw
// COLOR                    0   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xy          2     NONE   float   xy
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float   xyzw
// COLOR                    0   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xy          2     NONE   float   xy
// TEXCOORD                 1   xyzw        3     NONE   float   xyzw
// TEXCOORD                 2   xyzw        4     NONE   float   xyzw
//
vs_4_0
dcl_constantbuffer CB0[7], immediateIndexed
dcl_constantbuffer CB1[7], immediateIndexed
dcl_constantbuffer CB2[4], immediateIndexed
dcl_constantbuffer CB3[21], immediateIndexed
dcl_input v0.xyzw
dcl_input v1.xyzw
dcl_input v2.xy
dcl_output_siv o0.xyzw, position
dcl_output o1.xyzw
dcl_output o2.xy
dcl_output o3.xyzw
dcl_output o4.xyzw
dcl_temps 3
mul r0.xyzw, v0.yyyy, cb2[1].xyzw
mad r0.xyzw, cb2[0].xyzw, v0.xxxx, r0.xyzw
mad r0.xyzw, cb2[2].xyzw, v0.zzzz, r0.xyzw
add r0.xyzw, r0.xyzw, cb2[3].xyzw
mul r1.xyzw, r0.yyyy, cb3[18].xyzw
mad r1.xyzw, cb3[17].xyzw, r0.xxxx, r1.xyzw
mad r1.xyzw, cb3[19].xyzw, r0.zzzz, r1.xyzw
mad r0.xyzw, cb3[20].xyzw, r0.wwww, r1.xyzw
mov o0.xyzw, r0.xyzw
mad r0.xyz, v1.xyzx, l(0.265885, 0.265885, 0.265885, 0.000000), l(0.736584, 0.736584, 0.736584, 0.000000)
mad r0.xyz, v1.xyzx, r0.xyzx, l(-0.00980184041, -0.00980184041, -0.00980184041, 0.000000)
mad r0.xyz, v1.xyzx, r0.xyzx, l(0.00319697009, 0.00319697009, 0.00319697009, 0.000000)
mad r1.xyz, v1.xyzx, l(0.084971, 0.084971, 0.084971, 0.000000), l(-0.000163029006, -0.000163029006, -0.000163029006, 0.000000)
lt r2.xyz, v1.xyzx, l(0.072549, 0.072549, 0.072549, 0.000000)
movc r0.xyz, r2.xyzx, r1.xyzx, r0.xyzx
movc r1.xyz, cb0[6].zzzz, r0.xyzx, v1.xyzx
mov r1.w, v1.w
mul o1.xyzw, r1.xyzw, cb0[2].xyzw
mad o2.xy, v2.xyxx, cb0[5].xyxx, cb0[5].zwzz
mov o3.xyzw, v0.xyzw
mul r0.xy, cb1[6].yyyy, cb3[6].xyxx
mad r0.xy, cb3[5].xyxx, cb1[6].xxxx, r0.xyxx
div r0.xy, r0.wwww, |r0.xyxx|
mad r0.xy, cb0[6].xyxx, l(0.250000, 0.250000, 0.000000, 0.000000), |r0.xyxx|
div o4.zw, l(0.000000, 0.000000, 0.250000, 0.250000), r0.xxxy
max r0.xyzw, cb0[4].xyzw, l(-20000000000.000000, -20000000000.000000, -20000000000.000000, -20000000000.000000)
min r0.xyzw, r0.xyzw, l(20000000000.000000, 20000000000.000000, 20000000000.000000, 20000000000.000000)
mad r0.xy, v0.xyxx, l(2.000000, 2.000000, 0.000000, 0.000000), -r0.xyxx
add o4.xy, -r0.zwzz, r0.xyxx
ret
// Approximately 0 instruction slots used

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
