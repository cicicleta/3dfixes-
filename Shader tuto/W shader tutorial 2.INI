https://github.com/bo3b/3Dmigoto/wiki


;;;;;;;;;;;;;;;;;;;;explication Masterotaku;;;;;;;;;;;;;;;;;;;;;
First of all, you need to load the stereoparams and optionally the iniparams (for shader overrides, hotkeys, etc):

float4 iniparams = IniParams.Load(0);

float4 stereo = StereoParams.Load(0);

float separation = stereo.x;

float convergence = stereo.y;



First thing to try when something is at screen depth is this code:

o0.x-=separation*(o0.w-convergence);



"o0" can be other variables, depending on which you need to change (o1, o2, r0, r1, r2, etc).
 That line of code has into account the separation of the left and right images, so the effect has positive value
 to one eye and negative to the other, convergence and the depth value of the effect (the "w" axis).
 Make sure the variable you're modifying has "w" axis. In a vertex shader not related to lighting,
 I once needed to use the depth value of a different variable. So you can use the "w" of a different variable
 if you know that it is at the same position.


In my case, the fix above wasn't enough. It just made the effect visible at any convergence setting.
 I needed to modify the pixel shader. And this was the result:

r1.x-=separation*(r1.w-convergence*0.07);



First thing to remember is that the effect of "r" variables is applied "in real time" inside of the method at many points.
 So you may have to try fixing it at different steps, because you may be changing the position, or the color,
 or other effects inside it, etc.

About my line of code, it's very similar to the other one. What does that "*0.07" mean, you may ask? It's the influence
 of the convergence. Without it, when increasing convergence the lights moved at a much faster pace than they should. So I had
 so slow it down to the point where the lights are always at their correct position, no matter the convergence setting.
 Trial and error.

Now shadows are very different monster that I couldn't fix yet in that game. They don't change their angle when increasing
 depth (the rest of the scenery does), and that's a very big problem that I still don't know how to fix.

I hope this explanation can help you. 


;;;;;;;;;;;;;;;;;;;;explication Masterotaku;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;sun light;;;;;;;;;;;;subnautica
  r0.xyzw = cb4[1].xyzw * v0.yyyy;
  r0.xyzw = cb4[0].xyzw * v0.xxxx + r0.xyzw;
  r0.xyzw = cb4[2].xyzw * v0.zzzz + r0.xyzw;
  r0.xyzw = cb4[3].xyzw + r0.xyzw;
  r1.xyzw = cb5[18].xyzw * r0.yyyy;
  r1.xyzw = cb5[17].xyzw * r0.xxxx + r1.xyzw;
  r1.xyzw = cb5[19].xyzw * r0.zzzz + r1.xyzw;
  r0.xyzw = cb5[20].xyzw * r0.wwww + r1.xyzw;
  o0.xyzw = r0.xyzw;
  

float4 stereo = StereoParams.Load(0);
//r0.x -= stereo.x * r0.w * testeo.x;
r0.x -= stereo.x * r0.w * 0.9;
;;;;;;;;;;;;;;;;;;;;sun light;;;;;;;;;;;;subnautica


;;;;;;;;;;;;;;;;;;;;;;; Texture Filtering ;;;;;;;;;;;;;;;;;;;;;;;;;;
[ShaderOverrideHUD]

Hash=xxx

x2=ps-t0

[TextureOverrideCrosshair]

Hash=xxx

filter_index=2

;;;;

float4 stereo = StereoParams.Load(0);

float4 tex_filter = IniParams.Load(int2(2,0));

if (tex_filter.x == 2) {

 o0.x += stereo.x * 0.9;}
 
 
 
 -----------------------------
 Fuzzy Attribute Based TextureOverride Matching
TextureOverride sections can now match resources based on attributes rather than hash.
 This allows fewer TextureOverride sections to be used to match multiple variations of texture,
 which is especially useful if some property of the resource (such as the size or anti-aliasing) varied wildly.
 This also provides a clearer and more powerful alternative to using driver heuristics to set which resources are stereo
 and which are mono being as general or specific as you need.
The following options can be added to [TextureOverride] section that can be used to match resources as an alternative to using
 the hash. If an option is not specified then it simply won't be considered when matching resources:

match_type = Buffer | Texture1D | Texture2D | Texture3D
Specifies what kind of resource this TextureOverride section can match. If not specified, this will automatically be determined
 based on which other match options are specified (e.g. if you specify match_height it can only match 2D or 3D textures).
match_usage = default | immutable | dynamic | staging
Most resources that we are interested in will be match_usage=default
match_format = dxgi_format

Matches a specific format, such as "match_format=R8G8B8A8_TYPELESS". There is no "or" operator to match multiple formats
 (as you may need to do when stereoising a reflection's colour and depth buffers), but you can use a second TextureOverride instead.
Usually you will get this from ShaderUsage.txt, but there is a list of formats here:
https://msdn.microsoft.com/en-us/library/windows/desktop/bb173059(v=vs.85).aspx
match_byte_width
match_stride
match_mips
match_width
match_height
match_depth
match_array
match_msaa
match_msaa_quality

These options all specify an exact value to match, or can be a simple expressions in the form:
-[ op ] value | special [ * numerator ] [ / denominator ]
Where:
    "op" is one of = ! < <= > >=
    It will look a little weird because of the = from the ini file (match_width = >= res_width).
    value specifies an exact value to match
    special = width | height | depth | array | res_width | res_height
    res_width & res_height are affected by get_resolution_from
    You can use "match_width = height" to match a square resource, or "match_width = !height" to match a rectangular one
    numerator and denominator must both be integers. They must also be in this exact form - this is not a full expression parser.
This allows you to do things like match textures of a specific aspect ratio, or some scaled value of the resolution, or a resource
 that is at least some size.
match_bind_flags = vertex_buffer | index_buffer | constant_buffer
                 | shader_resource | stream_output | render_target
                 | depth_stencil | unordered_access | decoder
                 | video_encoder
match_cpu_access_flags = read | write
match_misc_flags = generate_mips | shared | texturecube
                 | drawindirect_args | buffer_allow_raw_views
                 | buffer_structured | resource_clamp
                 | shared_keyedmutex | gdi_compatible | shared_nthandle
                 | restricted_content | restrict_shared_resource
                 | restrict_shared_resource_driver | guarded | tile_pool
                 | tiled | hw_protected
These are flags fields - you can combine multiple flags by separating them with spaces. If a flag is prefixed by a '+' it must be
 present, but other flags will also be allowed. If a flag is prefixed by a '-' it must *not* be present to match. If no '+' or '-'
 modifiers are used the flags must match exactly. Hex strings may be used as an alternative to the textual names.
In addition to the above, there is also a "match_priority" setting that can be used to indicate which TextureOverride to prioritise 
if multiple sections match the same resource. If a given resource matches any TextureOverride by hash, that is considered an exact
 match and none of the other fuzzy matches will be considered at all.
If a given resource matches multiple fuzzy TextureOverrides, they will all be applied in an order dictated by their match_priority 
and ini section name. For things such as StereoMode, filter_index, and the dimension overrides the highest priority match will
 take effect. For checktextureoverride, this dictates the order that the command lists in these TextureOverrides will be executed.
 0 is the default priority, positive numbers are higher priority / later execution, lower/negative numbers are lower
 priority / earlier execution.
e.g. to force all square render targets to stereo:
[TextureOverrideSquareRenderTargets]
match_width = height
match_bind_flags = +render_target
StereoMode = 1
e.g. To force all UAVs that are not also RTVs to mono (simulating StereoFlagsDX10 = 0x0000C000, but without losing the ability

 to stereoise specific StructuredBuffers):
[TextureOverrideForceUAVsThatAreNotRTVsToMono]
match_bind_flags = +unorderd_access -render_target
StereoMode = 2
But maybe we want all StructuredBuffer UAVs to be stereo:

[TextureOverrideForceStructuredUAVsToStereo]
match_priority = 1
match_misc_flags = buffer_structured
match_bind_flags = +unorderd_access
StereoMode = 1

e.g. Maybe this game has a bunch of mirrors that we need to stereoise, but they are all different sizes and the
 AA setting changes their hash as well... but their formats are always the same and luckily don't clash with shadow maps:
[TextureOverrideMirrorsColour]
match_type = Texture2D
match_format = R8G8B8A8_TYPELESS
match_bind_flags = +render_target
StereoMode = 1
[TextureOverrideMirrorsDepth]
match_type = Texture2D
match_format = R16_TYPELESS
match_bind_flags = +depth_stencil
StereoMode = 1
e.g. Stereoise everything that is 3/4 of the resolution:
[TextureOverrideStereoiseResoluiton]
match_width = res_width * 3 / 4
match_height = res_height * 3 / 4
StereoMode = 1
 
 
 
 ;;;;;;;;;;;;;;;;;;;;;;; Texture Filtering ;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 
 ;;;;;;;;;;;;;;;;; Render target size filtering:  ;;;;;;;;;;;;;;;;;

[ShaderOverrideHUDBlue]

; Some HUD elements are drawn to an offscreen buffer before being copied to the

; screen. Check render target dimensions to determine which it is

Hash = bd5bda832fe2c401

x1 = rt_width

y1 = rt_height

z1 = res_width

w1 = res_height


;This passes the dimensions of the active render target to the shader in IniParams.Load(int2(1,0)).xy,
;and the current resolution in zw. Then you can do something like this to check if the shader is drawing to the screen:

float4 rt_filter = IniParams.Load(int2(1,0));

if (rt_filter.x == rt_filter.z && rt_filter.y == rt_filter.w) {

  // Render target dimensions match resolution - adjust UI depth

}

 ;;;;;;;;;;;;;;;;; Render target size filtering:  ;;;;;;;;;;;;;;;;;
 
 
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Partner shader filtering.;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 ; Partner shader filtering. Currently relies on the fact that 3DMigoto

; processes the vertex shader override before the pixel shader override to set

; y2 to 0 when any non-specified pixel shader is in use. TODO: Implement single

; draw call duration in 3DMigoto to make this feature explicit.

; This shader is responsible for a few effects, one of which (the wet rocks

; around one of the waterfalls in the desert level) requires the stereo

; correction to be applied, the others don't.

[ShaderOverrideWetRocksDecalsEtcVS]

Hash = e40b51d48a2da321

y2 = 0

[ShaderOverrideWetRocksPS]

Hash = 6f40f49445e70982

y2 = 1


Then in the vertex shader:

// Need to apply the stereo correction when this shader is used for wet rocks

// to stop them clipping, but don't want to apply it when the shader is used

// for decals. y2 is set to 1 only when the wet rocks pixel shader is active:

float4 wet_rocks = IniParams.Load(int2(2,0));

if (wet_rocks.y) {

	// Apply stereo correction to prevent wet rocks clipping around desert waterfall:

	float4 stereo = StereoParams.Load(0);

	o0.x += stereo.x * (o0.w - stereo.y);

}


The reason this works, is that the vertex shader override will always set y2 to 0 first,
 then if that pixel shader is active it will then set y2 to 1. 
 This can be expanded if necessary to match more pixel shaders.
 
 You can find examples of both forms of partner shader filtering in the Lichdom Battlemage fix:
https://github.com/DarkStarSword/3d-fixes/blob/master/Lichdom%20Battlemage/d3dx.ini


[ShaderOverridePS1]
Hash=2d97af187d677634
w = 1
post w = 0



[ShaderOverridePS2]
Hash=55839b09faca96f8
w = 2
post w = 0


That sets w to 1 or 2 at the start of the draw call, then clears it back to 0 afterwards.
 You can use any of the IniParams for this, not just w, and you can set it to the same value
 from multiple shaders if the vertex shader will do the same thing for several of them.
 In the vertex shader you would check it like this:

float partner = IniParams.Load(0).w;
if (partner == 1) {
	// 2d97af187d677634 is active, do whatever is needed
} else if (partner == 2) {
	// 55839b09faca96f8 is active, do whatever is needed
}




 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Partner shader filtering.;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 
;;;;;;;;;;;;;;;;;;;;;infinity;;;;;;;;;;;;;;;;;
 o0.x += separation * convergence;  which will move the sky to infinity
;;;;;;;;;;;;;;;;;;;;;infinity;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;,,disable shader;;;;;;;;;;;;;;
In the "d3dx.ini", put something like this with the hash of the vertex or pixel shader you want to disable:

[ShaderOverride1]

Hash=e803ab557d0d06d9
Handling=skip
;;;;;;;;;;;;;;;;;;;;;,,disable shader;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;textures copying;;;;;;;;;;;;;;;;;;;;;
There's also keywords to control some advanced features.
 For example, 3DMigoto will try to guess whether it should do a full copy of a resource,
 or only a lightweight reference, but maybe you want to override this:

[ResourceTempStorage]

[ShaderOverrideFoo]

Hash = foo

; Assigning *to* a temporary resource defaults to copying, but maybe we
; actually want a reference either to get any updates the game makes to the
; original texture, or because we know the resource won't change before we need
; to use it:

ResourceTempStorage = reference ps-t0



[ShaderOverrideBar]

Hash = bar

; Assigning *from* a temporary resource defaults to reference, but perhaps the
; temporary resource doesn't have the right bind flags for what we are
; assigning it to, or we want it leave it assigned in this slot while
; preventing it from getting updated if the game changes the original:

ps-t110 = copy ResourceTempStorage

By default, if you try to copy something that wasn't bound, 3DMigoto will unbind the destination as well. But, perhaps the
 resource you are copying is only bound some of the time, and if it is not bound you want to leave whatever was previously bound
 in the destination alone:

[ShaderOverrideBaz]

Hash = baz
ps-t50 = o2 unless_null

;;;;;;;;;;;;;;;;;;;;;;;;textures copying;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;screen in game;;;;;;;;;;;;;;;;;;;;;

If it's a display on a screen in the game that is being adjusted, your best bet is render target size filtering
 so you only adjust the HUD when it's being drawn directly to the screen:

[Device]



...



get_resolution_from = swap_chain

; If swap_chain does not result in the correct values for res_width and

; res_height when using a non-native resolution, try depth_stencil instead:

;get_resolution_from = depth_stencil



[ShaderOverrideHUDMFD]

; Inject the current render target dimensions and screen resolution into the

; shader:

Hash = xxxxxxxxxxx

x1 = rt_width

y1 = rt_height

z1 = res_width

w1 = res_height



And in the shader:

// Only adjust UI depth when we are drawing to a render target that matches the

// screen resolution:

float4 rt_filter = IniParams.Load(int2(1,0));

if (rt_filter.x == rt_filter.z && rt_filter.y == rt_filter.w) {

	// Move to infinity:

	float4 stereo = StereoParams.Load(0);

	o0.x += stereo.x * stereo.y;

}




If the vertex shaders are shared but the pixel shaders are not, you can filter based on the partner shader
 (there's a few ways this can be achieved, this is the best way if you are using 3DMigoto 1.2.5 or later,
 as it is the most flexible and can work with any type of shader):

[ShaderOverrideHUDPixelShader]

Hash = xxxxxxxx

x = 1

post x = 0



Then in the vertex shader you can check IniParams.Load(0).x, which will be 1 if that pixel shader is active and 0 otherwise.


I don't think this is your problem, but if it's that you need to separate out textures beyond what can be done
 with regular texture filtering (e.g. if a game uses a single texture containing a number of icons or HUD elements 
 and you only want to match one), you can check the texture coordinates so long as the texture does not change during the game:

// If v1 is the texture coordinate...

if (v1.x >= 0.7 && v1.x <= 0.75 && v1.y >= 0.2 && v1.y <= 0.3) {

	// texture coordinates match, move to infinity:

	float4 stereo = StereoParams.Load(0);

	o0.x += stereo.x * stereo.y;

}


;;;;;;;;;;;;;;;;;;;;screen in game;;;;;;;;;;;;;;;;;;;;;
 
 

;;;;;;;;;;;;;;;;;;;;declare IniParams ;;;;;;;;;;;;;;;;;;;;;
 
You declare them like this (t125 is StereoParams, t120 is IniParams):

dcl_resource_texture2d (float,float,float,float) t125

dcl_resource_texture1d (float,float,float,float) t120



And you load them like this:

ld_indexable(texture2d)(float,float,float,float) r17.xyzw, l(0, 0, 0, 0), t125.xyzw

ld_indexable(texture1d)(float,float,float,float) r18.xyzw, l(0, 0, 0, 0), t120.xyzw



Obviously you should change the temporary registers to whichever ones you are using,
 and remember that you need to bump dcl_temps up to EXACTLY ONE HIGHER
 than the highest temporary register number you have used.
 
 
float x = IniParams.Load(0).x;

float x1 = IniParams.Load(int2(1, 0)).x;

float x2 = IniParams.Load(int2(2, 0)).x;

float y7 = IniParams.Load(int2(7, 0)).y; 
 
 
 
 
dcl_resource_texture1d (float,float,float,float) t120
...
ld_indexable(texture1d)(float,float,float,float) r12.xyzw, l(0, 0, 0, 0), t120.xyzw 


Note that it is texture1d, not texture2d. If you want to load say x2/y2/z2/w2 you do:

ld_indexable(texture1d)(float,float,float,float) r8.xyzw, l(2, 0, 0, 0), t120.xyzw





For IniParams x/y/z/w you want:
dcl_resource_texture1d (float,float,float,float) t120
ld_indexable(texture1d)(float,float,float,float) r12.xyzw, l(0, 0, 0, 0), t120.xyzw

Note that it is texture1d, not texture2d. If you want to load say x2/y2/z2/w2 you do:
ld_indexable(texture1d)(float,float,float,float) r8.xyzw, l(2, 0, 0, 0), t120.xyzw
 
 
 ;;;;;;;;;;;;;;;;;;;;declare IniParams ;;;;;;;;;;;;;;;;;;;;;
 
 
 ;;;;;;;;;;;;;;;;copy render target;;;;;;;;;;;;;;;
 
 
     [ResourceNewRenderTarget]



    [ShaderOverrideWithInjectedRenderTarget]

    Hash = ...

    ; Make the new render target compatible with the existing one (3DMigoto will

    ; automatically choose "copy" since the destination is a custom resource, but

    ; it's important for this scenario so I'm specifying it explicitly):

    ResourceNewRenderTarget = copy o0

    ; Then add it as a second render target (3DMigoto should automatically choose

    ; "reference" since the destination is an output slot and the source is a

    ; custom resource, but it's important for this scenario so I'm specifying it

    ; explicitly):

    o1 = reference ResourceNewRenderTarget

    ; Unbind the render target after the draw call to make sure it won't cause

    ; any issues for the game, and so we can reference it in a texture slot later:

    post o1 = null



    [ShaderOverrideWithInjectedTexture]

    Hash = ...

    ; Now copy it into this shader as a texture (either "copy" or "reference"

    ; should work, but if you use reference make sure it's not bound as both an input

    ; and an output simultaneously by explicitly unbinding it after the draw

    ; calls):

    ps-t108 = copy ResourceNewRenderTarget

    ; Unbind the texture after the draw call - not strictly necessary since we

    ; copied it into this shader instead of referencing it, but good practice for

    ; any resource that is to be used as both an input and an output:

    post ps-t108 = null




Would you give me an example please of how to add that reference to o1 in the shader code? Shall I just add the

out float4 o1 : SV_Target1 ? 


[ResourceHeadlights]

[ShaderOverride-c0677e8702c32f18]

Hash = c0677e8702c32f18

ps-t111 = copy ResourceHeadlights

post ps-t111 = null



[ShaderOverride-4977ae594eb27c06]

Hash = 4977ae594eb27c06

ResourceHeadlights = copy o0

o1 = reference ResourceHeadlights

post o1 = null

;;;;;;;;;;;;;;;;copy render target;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;HUD desired Depth;;;;;;;;;;;;;;;;;;;;;;;;;

o0.x += separation * convergence * (1 - (o0.w / desired_depth));

;;;other
o0 *= 0.2;


Adjust the constant to find something suitable. Between 0 and 1 (not inclusive)
moves it closer to the camera, > 1 moves further away.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;HUD desired Depth;;;;;;;;;;;;;;;;;;;;;;;;;
 
 
;;;;;;;;;;;;;;;;;;;;;x y z w error ;;;;;;;;;;;;;;;;;;;;;;

    The error looks always the same :

    D:\jeux\DCS World 2 OpenAlpha\wrapper1349(90,14-19): error X3018: invalid subscript 'xyz'

    and the line 90 for this particular shader is

    r2.xyz = v3.xyz;


    so I think I only have to replace it by

    r2 = v3;


Yeah, that error is fairly common and that will usually work, 
though if v3 was split into two variables like v3 and w3 you might need to do something like:

r2.xy = v3.xy;

r2.z = w3.x;

;;;;;;;;;;;;;;;;;;;;;x y z w error ;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;screen size ;;;;;;;;;;;;;;;;;;;;;;;;;
You can define a [ShaderOverride] section for the shader and pass the current
 resolution width & height in with some IniParams, e.g.

[ShaderOverrideNeedScreenAdjustment]

hash = ...

x1 = res_width

y1 = res_height



I'm using x1 & y1 here, but you can choose any of the 32 available Ini Params
(x, x1, x2, ..., x7, ditto for y, z & w). If you are using any of the ones that end
 in a number the syntax to load it is slightly different:

float4 res = IniParams.Load(int2(1, 0));

;;;;;;;;;;;;;;;;;;;screen size ;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;debug2d;;;;;;;;;;;;;;;;;;;
[CustomShaderDebug2D]

vs = ShaderFixes\full_screen.hlsl
ps = ShaderFixes\debug_2d.hlsl
blend = ADD SRC_ALPHA INV_SRC_ALPHA
cull = none
topology = triangle_strip
o0 = bb
ps-t100 = ResourceDebug2D
Draw = 4, 0
post ps-t100 = null


[Present]

run = CustomShaderDebug2D
full_screen.hlsl:
void main(

                out float4 pos : SV_Position0,

                out float4 spos : TEXCOORD0,

                out float2 tpos : TEXCOORD1,

                uint vertex : SV_VertexID)

{

        // Not using vertex buffers so manufacture our own coordinates.

        switch(vertex) {

                case 0:

                        pos.xy = float2(-1, -1);

                        break;

                case 1:

                        pos.xy = float2(-1, 1);

                        break;

                case 2:

                        pos.xy = float2(1, -1);

                        break;

                case 3:

                        pos.xy = float2(1, 1);

                        break;

                default:

                        pos.xy = 0;

                        break;

        };

        pos.zw = float2(0, 1);

        spos = pos;

        tpos = pos.xy * float2(0.5,-0.5) + 0.5;

}



debug_2d.hlsl:

Texture2D<float4> tex : register(t100);

Texture1D<float4> IniParams : register(t120);



void main(float4 pos : SV_Position0, float4 spos: TEXCOORD0, float2 tpos: TEXCOORD1, out float4 result : SV_Target0)

{

        uint width, height;

        tex.GetDimensions(width, height);



        result = tex.Load(int3(tpos.xy * float2(width, height), 0));

}
 
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;debug2d;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

d3dx.ini:

[ResourceDebug2D]

filename=3DMigoto.png



[CustomShaderDebug2D]

vs = ShaderFixes\full_screen.hlsl

ps = ShaderFixes\debug_2d.hlsl

blend = ADD SRC_ALPHA INV_SRC_ALPHA

cull = none

topology = triangle_strip

o0 = bb

ps-t100 = ResourceDebug2D

Draw = 4, 0

post ps-t100 = null



[Present]

run = CustomShaderDebug2D



full_screen.hlsl:

void main(

                out float4 pos : SV_Position0,

                out float4 spos : TEXCOORD0,

                out float2 tpos : TEXCOORD1,

                uint vertex : SV_VertexID)

{

        // Not using vertex buffers so manufacture our own coordinates.

        switch(vertex) {

                case 0:

                        pos.xy = float2(-1, -1);

                        break;

                case 1:

                        pos.xy = float2(-1, 1);

                        break;

                case 2:

                        pos.xy = float2(1, -1);

                        break;

                case 3:

                        pos.xy = float2(1, 1);

                        break;

                default:

                        pos.xy = 0;

                        break;

        };

        pos.zw = float2(0, 1);

        spos = pos;

        tpos = pos.xy * float2(0.5,-0.5) + 0.5;

}



debug_2d.hlsl:

Texture2D<float4> tex : register(t100);

Texture1D<float4> IniParams : register(t120);



void main(float4 pos : SV_Position0, float4 spos: TEXCOORD0, float2 tpos: TEXCOORD1, out float4 result : SV_Target0)

{

        uint width, height;

        tex.GetDimensions(width, height);



        result = tex.Load(int3(tpos.xy * float2(width, height), 0));

}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;debug2d;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;copy resources;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

If destination is one of the following:

[vhdgpc]s-cb[0-13] (constant buffer slot)
[vhdgpc]s-t[0-127] (texture / other shader resource slot)
vb[0-31] (vertex buffer slot)
ib (index buffer slot)

The resource will be bound as in input. If it is one of these:

o[0-7] (render target slot)
oD (depth/stencil slot)
so[0-3] (stream output slot)

It will be bound as an output. If it is one of these:

ps-u[0-7] (pixel shader UAV slot)
cs-u[0-7] (compute shader UAV slot)

It is simultaneously an input and output.

With the exception of UAVs, resources cannot be bound to both an input and output slot simultaneously,
 and attempting to do so will either fail to bind it, or will forcefully unbind it from wherever else
 it is bound in the pipeline. Performing a full copy is the easiest way to avoid this scenario.


If a resource is copied by reference (either as a default of 3DMigoto, or by specifying the 'reference' keyword,
 the source will be bound to the destination directly. This is a lightweight operation so performance reasons
 it can be a good idea to use this when it makes sense, and it is necessary for some use cases
 (such as binding a custom render target / UAV). But, as it is the SAME resource then the above rules apply that it cannot
 be bound as both an input and output simultaneously. Leaving such a resource bound anywhere can be risky as the game does
 not know that it is bound, and may try to bind it elsewhere in the pipeline and violate that rule. Copying by reference may 
 or may not work between different slot types, depending on the bind flags that the game used when creating the resource
 (and a few other restrictions). 3DMigoto may still create a new resource view, so in some rare cases there might be differences
 observed from the POV of the shader.

If a full copy is performed (either as a default of 3DMigoto, or by specifying the 'copy' keyword),
 the resource destination will receive a COPY of the source resource, and will BE A DIFFERENT RESOURCE to the source.
 This avoids the risk of I/O conflicts since it is not the same, and means that the copy is a snapshot of the original
 resource at the time it was copied (whereas copying by reference may still allow the game to change it later,
 though sometimes you may want that). A full copy is also required for 3DMigoto to change certain details about the resource,
 such as changing it's bind flags to allow it to be bound to a different slot type than the game intended.
 
 
;------
 The default rules are (first rule matched will be used):
 
1. If the destination is a custom resource: use a full copy (ensures that bind flags are changed as necessary,
 and prevent surprises if the game later overwrites the source resource)

2. If the destination is a render target: copy by reference (assumes we want the result of the draw operation
 in the resource we assigned)

3. If the source is a custom resource: copy by reference (assumes that the custom resource will have already been created
 through a full copy to set the required bind flags)

4. If the source and destination are the same slot type: copy by reference (likely to be safe, and lightweight)

5. In any other case: perform a full copy (may need to change bind flags or avoid I/O conflicts)


Keywords include:
- copy - perform a full copy of the resource

- ref / reference - copy the resource by reference

- copy_desc / copy_description - make the destination resource have the same description as the source
 (width, height, format, etc. except for any overridden in the resource section), but do not actually copy
 the source resource. Used to create simultaneous render targets.  copy_desc oD

- unless_null - abort the copy operation if nothing is bound to the source. Does not increment the resource copy
 count for the frame.

- stereo - when creating the destination resource for a full copy, set the driver creation mode create it as a stereo resource.

- mono - As above, but set the creation mode to a mono resource.

- stereo2mono - perform a full copy using the reverse stereo blit that ends up with a double width mono resource with
the image for the right eye on the left and vice versa. Current limitations: does not work with MSAA resources,
 and only the most detailed mip-map will have the information for the second eye.

- set_viewport - Set the DirectX viewport to match the dimensions of the source resource to ensure that the entire
 resource can be written to. Useful when assigning the back buffer as a render target (note - the original viewport
 cannot be restored through resource copying, but if this is run from a CustomShader section that will take care
 of backing up and restoring it).

- no_view_cache - Never cache the resource view. Workaround for glitches in Mad Max when running a custom shader from
 the present call very early in launch.

- resolve_msaa - Ask the hardware to resolve an MSAA resource into a non MSAA resource. This will not work for all resources,
 and it is not clear how universal the support is, so I do not recommend relying on it for now 
 (e.g. my card cannot resolve MSAA depth buffers). A safer solution would be to use a custom shader to perform this operation
 instead, and eventually I would like to build that into 3DMigoto so that this works more universally. 
 
 You might choose to use a full copy when, e.g.:
- You are copying a resource that the game might later change and you DON'T want to see those changes
 (e.g. copying a constant buffer for the matrices used in a specific draw operation, as they are likely to be clobbered 
 by a later draw operation)
- You are copying a resource between different slot types (exception: if the game created the resource with certain
 bind flags it may be possible to copy it by reference in some cases)
- You need to copy an output to an input (or vice versa) and have them bound simultaneously.

You might choose to use a copy by reference when, e.g.:
- A full copy is too expensive (alternative: max_copies_per_frame=1). I really can't emphasise enough 
- full copies are expensive, if it only happens once or twice in a frame you won't notice it, but if it happens 40 times
 you will see a dip in the fps (or at least, anyone who is GPU bound will), and if it happens 400 times the game may be unplayable.
- You are grabbing a reference to a resource that you expect the game to update and you WANT to see those updates
 (e.g. grabbing a reference to the depth buffer before the game has finished drawing it for the frame)
- Driver heuristics mess up a full copy and you only get a mono copy where you wanted a stereo copy
 (e.g. take a look at the debugging shaders in Far Cry Primal where a full copy of the fog volumes show them in mono,
 and a copy by reference show them in stereo).
 
 
 
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;copy resources;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;crash;;;;;;;;;;;;;;;;;;;;;; 
 unbuffered=1
 allow_create_device=1
 allow_dxgi1_2=2 
 ;;;;;;;;;;;;;;;;;;;;;;;;crash;;;;;;;;;;;;;;;;;;;;;;
 
;;;;;;;;;;;;;;;;;;;;;;;;;formulas;;;;;;;;;;;;;;;;;;;;;;;
o0.x -= separation * (o0.w - convergence);
o0.x += separation * (o0.w - convergence);
o2.x += separation * (o0.w - convergence);
o2.x += separation * (o0.w - convergence) / o0.w; 
 ;;;;;;;;;;;;;;;;;;;;;;;;;formulas;;;;;;;;;;;;;;;;;;;;;;;
 
 
 ;;;;;;;;;;;;;;;;;;;;;;;;asm instructions;;;;;;;;;;;;;;;;;;;;;;;;;
 SM4/5 assembly separated out the comparison instructions from the flow control 
 (there's benefits on a hardware level of this design), so you first use one of the comparison instructions:

eq: floating point equals
ne: floating point not equals
ge: floating point greater or equal
lt: floating point less then
ieq: integer equals
ine: integer not equals
ige: signed integer greater or equal
ilt: signed integer less then
uge: unsigned integer greater or equal
ult: unsigned integer less then

There is no "less than or equal to" or "greater than" instructions - just swap the arguments around and use the opposite instruction
 if you need them.

Then use the if_nz / if_z to check the result of those instructions on a following line. 
(I think I noticed that if_nz and if_z did not always do what you expect if you try to use them on values not obtained
 from the above instructions, so best to always use them together). 
  ;;;;;;;;;;;;;;;;;;;;;;;;asm instructions;;;;;;;;;;;;;;;;;;;;;;;;;
  
  ;;;;;;;;;;;;;;;;;;;;;;;;stereo default on;;;;;;;;;;;;;;;;;;;
  [Profile]
StereoDefaultOn = 0

  ;;;;;;;;;;;;;;;;;;;;;;;;stereo default on;;;;;;;;;;;;;;;;;;;
  
  
 ;;;;;;;;;;;;;;;;;;;;;access resolution ;;;;;;;;;;;;;;;;;;;;;;;;
 [ShaderOverrideWhatever]
hash = _______
x1=rt_width
y1=rt_height
z1=res_width
w1=res_height

and the in the shader itself add
float4 ResParams = IniParams.Load(int2(1,0));
and ResParams.z will have the resolution width, and ResParams.w will have the height.

OR
float4 res = StereoParams.Load(int3(2,0,0));
And then using res.x and res.y. No shader override needed. 

OR
In most cases you can use either method to get the resolution. The subtle difference is that StereoParams
 gets the values from the driver, while res_width/height get it from the game. If you find they don't seem
 to match what the game is set to (CryEngine 3 always uses native resolution no matter what it is set to
 and upscales as needed and some UE4 games also have the option to render at a different resolution from the display)
 try changing get_resolution_from to depth_buffer and use the res_width/height in a ShaderOverride section.
Another trick is to use .GetDimensions(width, height) on a texture passed to the shader that you know matches the resolution. 

 ;;;;;;;;;;;;;;;;;;;;;access resolution ;;;;;;;;;;;;;;;;;;;;;;;;
 
 ;;;;;;;;;;;;;;;detph test;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 Do it in the shader so you can add depth threshold tests - the formula for a convergence override is:

pos.x += separation * (convergence - convergence_override);
;----
float4 stereo = StereoParams.Load(0);
if (o0.w < something) {
	o0.x += stereo.x * (stereo.y - something_else);
;----
o0 *= 1.1
;----
float4 stereo = StereoParams.Load(0);
if (o0.z < 0.4) {
 o0.x += stereo.x * 19;}
 
;;;;;;;;;;;;;;;detph test;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;matrix;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
When i after use below code to fix water wave effects

#include "matrix.hlsl"

// Common SVPositionToTranslatedWorld fix:
float4 s = StereoParams.Load(0);
matrix TranslatedWorldToClip = MATRIX(cb1, 0);
matrix ClipToTranslatedWorld = MATRIX(cb1, 32);
float4 t = mul(r2.xyz, TranslatedWorldToClip);
t.x -= s.x * (t.w - s.y);
r2.xyz = mul(t, ClipToTranslatedWorld);


wave effects fixed correctly

but
water's color has changed(disappeared)

loook at attached img plz

Perhaps the alpha channel's information is missing.

Depending on the depth of the water, the color that was expressed in various ways but became transparent.

so i used this code in ps.txt

//Fix
//Translate r2.xyz (world) to clip cb1[0,1,2,3]
mul r26.xyzw, r2.yyyy, cb1[1].xyzw
mad r26.xyzw, r2.xxxx, cb1[0].xyzw, r26.xyzw
mad r26.xyzw, r2.zzzz, cb1[2].xyzw, r26.xyzw
add r26.xyzw, r26.xyzw, cb1[3].xyzw
//Fix Clip
add r25.w, r26.w, -r25.y
mul r25.w, r25.x, r25.w
add r26.x, r26.x, -r25.w
//Translate r26.xyz (Clip) to world cb1[32,33,34,35]
mul r2.xyzw, r26.yyyy, cb1[33].xyzw
mad r2.xyzw, r26.xxxx, cb1[32].xyzw, r2.xyzw
mad r2.xyzw, r26.zzzz, cb1[34].xyzw, r2.xyzw
mad r2.xyzw, r26.wwww, cb1[35].xyzw, r2.xyzw

then color issue has gone
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;matrix;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;preset;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ShaderOverrideHUDSettingsAndInventory]
hash = bab4f74d620346c8
; Check for the inventory texture to activate a low convergence preset:
checktextureoverride = ps-t0

[TextureOverrideInventoryExamineCircles]
hash = b98c5309
preset = PresetExamineInventory

[PresetExamineInventory]
convergence = 0.5
x2 = 0.475
transition = 400
transition_type = cosine
release_transition = 300
release_transition_type = cosine


---more
[PresetMultipleConditions]
; Require two unique triggers to activate this preset:
unique_triggers_required = 2
; Do something
; Preset only activated when a particular distortion shader is in use:
[ShaderOverrideDistort]
hash = ...
preset = PresetMultipleConditions
; *And* when a specific texture is in use:
[ShaderOverrideFog]
hash = ...
checktextureoverride = ps-t0
[TextureOverrideFogTexture]
hash = ...
preset = PresetMultipleConditions
; But not when this other shader is in use:
[ShaderOverrideSomethingThatSignifiesThePresetIsWrong]
hash = ...
exclude = PresetMultipleConditions
exclude_preset = foo


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;preset;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;regex;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
This is a complete, working example from Hellblade that locates a matrix multiply
and injects a stereo correction before it. This example will work regardless of which registers
 the game used, and uses named capture groups to pull out the registers and components that contain
 the X and Z values (and another "result" capture group to check that the same register is used in two instructions,
 though this for demonstration purposes and is not actually required in this case),
 two temporary registers are defined named "stereo" and "tmp1" that can be used in the replace section,
 InsertDeclarations is used to define StereoParams, and ${0} is used to insert the entire matching pattern
 in the replaced text (this is how you insert text before or after a pattern):

[ShaderRegexScreenToShadowMatrix]

shader_model = ps_5_0
temps = stereo tmp1

[ShaderRegexScreenToShadowMatrix.Pattern]

mul r\d+\.xyzw, r\d+\.yyyy, cb0\[28\]\.xyzw\n
mad r\d+\.xyzw, (?P<pos_x>r\d+)\.(?P<swizzle_x>[xyzw])[xyzw]{3}, cb0\[27\]\.xyzw, r\d+\.xyzw\n
mad r\d+\.xyzw, (?P<pos_z>r\d+)\.(?P<swizzle_z>[xyzw])[xyzw]{3}, cb0\[29\]\.xyzw, r\d+\.xyzw\n
add (?P<result>r\d+)\.xyzw, r\d+\.xyzw, cb0\[30\]\.xyzw\n
div r\d+\.[xyzw]{2}, (?P=result)\.[xyzw]{4}, r\d+\.wwww\n

[ShaderRegexScreenToShadowMatrix.InsertDeclarations]
dcl_resource_texture2d (float,float,float,float) t125

[ShaderRegexScreenToShadowMatrix.Pattern.Replace]
\n// Shadows automatically corrected by DarkStarSword's UE4 autofix:\n
ld_indexable(texture2d)(float,float,float,float) ${stereo}.xyzw, l(0, 0, 0, 0), t125.xyzw\n
add ${tmp1}.x, ${pos_z}.${swizzle_z}, -${stereo}.y\n
mad ${pos_x}.${swizzle_x}, -${tmp1}.x, ${stereo}.x, ${pos_x}.${swizzle_x}\n
\n

${0}


-----

This is another example (also from Hellblade) that shows how this can be used in conjunction with a command list
 to copy a custom resource containing a matrix into the shader, and shows how you can use named capture groups
 to capture entire chunks of the original shader and decide where to place them in the replaced output
 (this is how to insert and/or alter text in the middle of a pattern). This example is a little more precise than
 the above one since it only matches shaders using the same register numbers - I'm not recommending either approach 
 at the moment: you could start with a more precise pattern and make it more flexible as you come across variations,
 or start with something more flexible and blacklist any shaders it shouldn't have been applied to - both are valid
 approaches and we need more real world experience to work out which is "better":

[ShaderRegexScreenToDecalMatrix]

shader_model = ps_5_0
temps = tmp1 m0 m1 m2 m3
; Need SV_Position stereoisation matrix:
ps-t90 = ResourceStereoInjectionMatrices
post ps-t90 = null


[ShaderRegexScreenToDecalMatrix.Pattern]
; Texture and sampler numbers known to vary. The indented whitespace here is
; for my reference, it is not part of the pattern and is not required:
(?P<prefix>

        mul r0\.xy, v0\.xyxx, cb1\[123\]\.zwzz\n
        sample_l_indexable\(texture2d\)\(float,float,float,float\) r0\.x, r0\.xyxx, t\d+\.xyzw, s\d+, l\(0\.000000\)\n
)

mul r1\.xyzw, v0\.yyyy, cb0\[2\]\.xyzw\n
mad r1\.xyzw, v0\.xxxx, cb0\[1\]\.xyzw, r1\.xyzw\n
mad r0\.xyzw, r0\.xxxx, cb0\[3\]\.xyzw, r1\.xyzw\n

(?<after>

	add r0\.xyzw, r0\.xyzw, cb0\[4\]\.xyzw\n
	div r0\.[xyzw]{3}, r0\.[xyzw]{4}, r0\.wwww\n
)



[ShaderRegexScreenToDecalMatrix.InsertDeclarations]

// Injection Matrices:
dcl_resource_structured t90, 64


[ShaderRegexScreenToDecalMatrix.Pattern.Replace]

${prefix}

\n

// SV_Position inverse stereoisation matrix:\n

ld_structured_indexable(structured_buffer, stride=64)(mixed,mixed,mixed,mixed) ${m0}.xyzw, l(0), l(0), t90.xyzw\n
ld_structured_indexable(structured_buffer, stride=64)(mixed,mixed,mixed,mixed) ${m1}.xyzw, l(0), l(16), t90.xyzw\n
ld_structured_indexable(structured_buffer, stride=64)(mixed,mixed,mixed,mixed) ${m2}.xyzw, l(0), l(32), t90.xyzw\n
ld_structured_indexable(structured_buffer, stride=64)(mixed,mixed,mixed,mixed) ${m3}.xyzw, l(0), l(48), t90.xyzw\n

\n

// Multiply SV_Position by injection matrix:\n

mul ${tmp1}.xyzw, v0.xxxx, ${m0}.xyzw\n
mad ${tmp1}.xyzw, v0.yyyy, ${m1}.xyzw, ${tmp1}.xyzw\n
mad ${tmp1}.xyzw, r0.xxxx, ${m2}.xyzw, ${tmp1}.xyzw\n
add ${tmp1}.xyzw, ${tmp1}.xyzw, ${m3}.xyzw\n

\n

// Adjust original matrix multiply to use inverse stereoised SV_Position:\n

mul r1.xyzw, ${tmp1}.yyyy, cb0[2].xyzw\n
mad r1.xyzw, ${tmp1}.xxxx, cb0[1].xyzw, r1.xyzw\n
mad r0.xyzw, ${tmp1}.zzzz, cb0[3].xyzw, r1.xyzw\n

${after}


As you can see there are four sections that make up this feature:

1. [ShaderRegex*] defines which shader models it matches and declares any temporary registers that you can use
 in the Replace section (which will automatically update/insert dcl_temps as required).
 This section also acts as a command list, which is appended to the ShaderOverride command list of all matching shaders.

2. [ShaderRegex*.Pattern] is a PCRE2 regular expression that will match part of the shader.

3. [ShaderRegex*.Pattern.Replace] is the text that will replace the matched pattern. Use ${0} to insert the original text
 the pattern matched, or use named capture groups to insert part of the matched pattern whereever it is needed.
 Temporary registers you have defined in the main section use the exact same syntax here as named capture groups here,
 like ${tmp1}, etc.

4. [ShaderRegex*.InsertDeclarations] is where you insert any additional declarations you need, which will typically be used
 for StereoParams. 3DMigoto will prevent these from being inserted if a 100% identical declaration is already in the shader
 (e.g. if multiple ShaderRegex sections match a single shader you still only want one StereoParams declaration).

A few things to point out here that might trip some people up:

1. Only assembly shaders can be patched using this engine. This is by design, for reliability and performance reasons.

2. The explicit newline characters \n in the pattern *and* replacement text are very important - try not to forget these,
 I am fully expecting they will be the number 1 thing wrong if a pattern isn't working.

3. Some characters like . [] () need to be escaped with a \ in the Pattern section because these have special meanings
 in regular expressions. You may be able to get away without escaping dots, but that is because a dot in a regular expression
 matches *any* character, which happens to include dots - you should try to remember to escape these as well to be on the safe side. These characters are not to be escaped in the Replace section.

4. Whitespace at the start and end of each line is ignored, but whitespace in the middle of a line is not.
 This is due to the ini parsing and is not inherently part of regular expressions, but it seems to work pretty well in practice
 (as you can see above, I indented some lines in the patterns for my reference). There is a switch you can use in the regular
 expression to ignore all whitespace (refer to the PCRE2 syntax guide), but that is separate to this.

5. The Replace section is ".Pattern.Replace", not just ".Replace". At the moment there can only be one of each, but the intent
 is that in the future we will support multiple patterns in a ShaderRegex group (e.g. to match part of a header in one pattern,
 and code in another), so the .Replace section is associated with a specific pattern.

The grammar we are using is the very powerful PCRE2, which is largely compatible with the Perl and Python
 (and I think .NET) grammars if you are familiar with any of those. I'm using Python style named capture groups above,
 but Perl and .NET styles work as well. The reference for PCRE2 is here (beware that if you aren't familiar with regular
 expressions this will look like Greek - any good regular expression tutorial should provide a good primer on the general
 syntax and only refer to this for specific details):

http://www.pcre.org/current/doc/html/pcre2syntax.html

The d3d11_log.txt will tell you if the pattern matched a shader, and will show you the patched shader - use this to make sure
 that the pattern is matching a shader at all, and applying correctly if it did match.

The hunting overlay will show the [ShaderRegex] section for any patched shaders. For debugging I recommend turning
 on the new verbose_overlay option to see the hash of these shaders to match these up with the log.

If you dump out a patched shader, you will get the *original* shader, not the patched version in ShaderFixes,
 and doing this will blacklist it from further consideration in the ShaderRegex engine until it has been removed
 from ShaderFixes. If you need the patched version, you can copy it out of the d3d11_log.txt (or bug me to add an option
 to switch this behaviour around).

This feature fully works with F10 reload (it is recommended to have both shader and config reload assigned to the same key)
 to adjust the patterns on the fly and see the results instantly in game. This includes unpatching shaders that no longer match,
 so what you see after an F10 reload should be the same as starting the game from scratch.

A few special uses of this feature for advanced users:

- The .Pattern.Replace section is optional. If you omit it the pattern will still be matched against shaders and the command list
 and .InsertDeclarations section will still be applied, it just won't replace the matched part of the shader.

- The .Pattern section is also optional. If you omit it the pattern will match every shader that matches the shader_model,
 and the command list and .InsertDeclarations section will still be applied. This can be used to do advanced things like
 globally disabling the driver's stereo correction via the cb12 method in InsertDeclarations, or running a command list
 for every shader.

Current Limitations & Performance Notes
- There is a slight performance hit of enabling the patching engine

- Shaders are patched when they are first used, which may introduce some minor stuttering during gameplay 
(in the future we may try to patch these at load time when possible to reduce this impact, but I have other reasons
 for doing this on the fly that are not apparent just yet).

- Patched shaders are not currently cached anywhere, so the cost will be paid every time the game is run,
 and again after any F10 reload.

- Each ShaderRegex section is currently limited to one pattern and one replace section - in the future we may allow for multiple
 patterns to make it easier to e.g. match a header with one pattern and use a value extracted from that header in the main patch.
 This can be done without this, but would require a more complicated pattern that matches the header and instructions
 and everything between. 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;regex;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;regex example;;;;;;;;;;;;;;;;;;;;;;
 [ShaderRegex_PSShadows_PSLights_CSLight_5]
shader_model = ps_4_0 ps_5_0 cs_5_0
temps = stereo tmp1

[ShaderRegex_PSShadows_PSLights_CSLight_5.Pattern]
(?P<section1>
^\s*?mul r\d+\.[xyzw]{2}, r\d+\.[xyzw]{4}, r\d+\.[xyzw]{4}$\n
)
(?P<section2>
^\s*?mul r\d+\.xyzw, r\d+\.yyyy, (?P<cbuffer>cb[01])\[\d+\]\.xyzw$\n
^\s*?mad r\d+\.xyzw, (?P<pos>r\d+)\.(?P<swizzle_pos>[xyzw]){4}, (?P=cbuffer)\[\d+\]\.xyzw, r\d+\.xyzw$\n
^\s*?mad r\d+\.xyzw, (?P<depth>r\d+)\.(?P<swizzle>[xyzw]){4}, (?P=cbuffer)\[\d+\]\.xyzw, r\d+\.xyzw$\n
^\s*?add r\d+\.xyzw, r\d+\.xyzw, (?P=cbuffer)\[\d+\]\.xyzw$\n
^\s*?div (?P<pos1a>r\d+)\.[xyzw]{3}, r\d+\.[xyzw]{4}, r\d+\.wwww$\n
^\s*?add (?P<pos2>r\d+)\.xyz, (?P=pos1a)\.[xyzw]{4}, -(?P=cbuffer)\[55\]\.[xyzw]{4}$\n
)

[ShaderRegex_PSShadows_PSLights_CSLight_5.Pattern.Replace]
${section1}\n
ld_indexable(texture2d)(float,float,float,float) ${stereo}.xyzw, l(0, 0, 0, 0), t125.xyzw\n
add ${tmp1}.x, ${depth}.${swizzle}, -${stereo}.y\n
mad ${pos}.${swizzle_pos}, -${tmp1}.x, ${stereo}.x, ${pos}.${swizzle_pos}\n
${section2}\n
mul ${tmp1}.xyz, ${stereo}.yyyy, ${cbuffer}[40].xyzx\n
mad ${pos2}.xyz, -${stereo}.xxxx, ${tmp1}.xyzx, ${pos2}.xyzx\n

[ShaderRegex_PSShadows_PSLights_CSLight_5.InsertDeclarations]
dcl_resource_texture2d (float,float,float,float) t125

----------------------------------------


[ShaderRegexLightingPS1]
shader_model = ps_5_0
temps = stereo tmp1 tmp2 tmp3 tmp4
[ShaderRegexLightingPS1.Pattern]
(?P<section0>
^\s*?movc (?P<depth>r\d+)\.(?P<depth_w>[xyzw]), r\d+\.[xyzw], r\d+\.[xyzw], l\(1\.000000\)$\n
^\s*?mul (?P<in0>r\d+).[xyzw]{2}, r\d+\.[xyzw]{4}, r\d+\.[xyzw]{4}$\n
)
(?P<section1>
^\s*?mul (?P<pos0>r\d+)\.(?P<pos0_sw1>[xyzw]{3,4}), (?P=in0)\.(?P<in0_y>[xyzw]){4}, (?P<cb>cb\d+)\[49\]\.(?P<cby_sw>[xyzw]{4})$\n
^\s*?mad (?P=pos0)\.(?P<pos0_sw3>[xyzw]{3,4}), (?P=in0)\.(?P<in0_x>[xyzw]){4}, (?P=cb)\[48\]\.(?P<cbx_sw>[xyzw]{4}), (?P=pos0)\.(?P<pos0_sw2>[xyzw]{4})$\n
^\s*?mad (?P<pos1>r\d+)\.(?P<pos1_sw1>[xyzw]{3,4}), (?P<in1>r\d+)\.(?P<in0_z>[xyzw]){4}, (?P=cb)\[50\]\.(?P<cbz_sw>[xyzw]{4}), (?P=pos0)\.(?P<pos0_sw4>[xyzw]{4})$\n
^\s*?add (?P<pos1b>r\d+)\.(?P<pos1b_sw1>[xyzw]{3,4}), (?P=pos1)\.(?P<pos1_sw2>[xyzw]{4}), (?P=cb)\[51\]\.(?P<cbw_sw>[xyzw]{4})$\n
;^\s*?div (?P<pos1a>r\d+)\.(?P<pos1a_sw1>[xyzw]{3}), (?P=pos1b)\.(?P<pos1b_sw2>[xyzw]{3,4}), (?P=pos1b)\.(?P<pos1b_sw3>[xyzw]{4})$\n
)
(?P<section2>
^\s*?add (?P<pos2>r\d+)\.xyz, (?P<pos3>r\d+)\.(?P<pos3_sw1>[xyzw]{3,4}), -(?P=cb)\[67\]\.xyzx$\n
)

[ShaderRegexLightingPS1.Pattern.Replace]
${section0}\n
ld_indexable(texture2d)(float,float,float,float) ${stereo}.xyzw, l(0, 0, 0, 0), t125.xyzw\n
mad ${in0}.${in0_x}, -${stereo}.x, ${in1}.${in0_z}, ${in0}.${in0_x}\n
mul ${tmp2}.${pos0_sw1}, ${in0}.${in0_y}${in0_y}${in0_y}${in0_y}, ${cb}[49].${cby_sw}\n
mad ${tmp2}.${pos0_sw3}, ${in0}.${in0_x}${in0_x}${in0_x}${in0_x}, ${cb}[48].${cbx_sw}, ${tmp2}.${pos0_sw2}\n
mad ${tmp2}.${pos1_sw1}, ${in1}.${in0_z}${in0_z}${in0_z}${in0_z}, ${cb}[50].${cbz_sw}, ${tmp2}.${pos0_sw4}\n
add ${tmp2}.${pos1b_sw1}, ${tmp2}.${pos1_sw2}, ${cb}[51].${cbw_sw}\n
mad ${in0}.${in0_x}, ${stereo}.x, ${stereo}.y, ${in0}.${in0_x}\n
${section1}\n
add ${pos2}.xyz, ${tmp2}.${pos3_sw1}, -cb[67].xyzx\n

[ShaderRegexLightingPS1.InsertDeclarations]
dcl_resource_texture2d (float,float,float,float) t125


--------------------------------------------

Just literally use "r0\.xyzw" if you want to specifically match r0 and xyzw components.
 If you want to match any register with swizzle xyzw use "r\d+\.xyzw" (which is the same as "r[0-9]+\.xyzw"),
 and if you need to capture that register number with a capture group, use "(?P<capture_group_name>r\d+)\.xyzw"

In the example you quoted I'm capturing the register and the first component of the swizzle (specifically the first
 - I expect them all to be the same, but in the replace text I only wanted to output a single character,
 so I only captured one) and allowed the remaining three to match any swizzle character without capturing them.
 To break it down:
 
(?P<pos_x>r\d+)\.(?P<swizzle_x>[xyzw])[xyzw]{3}

(?x) (?# Enables extended mode to ignore all whitespace for a verbose breakdown)

(?P<pos_x>  (?# This opens a named capture group for the register number)
	r   (?# Matches the literal "r" for a temporary register)
	\d+ (?# Matches one or more digits for the register number)
)	    (?# Closes this named capture group)

\. (?# Matches a literal dot between the register number and swizzle)

(?P<swizzle_x> (?# Opens a named capture group for the *first* character in the swizzle)
- [xyzw] (?# Matches exactly one swizzle character, which can be any of these)
)	       (?# Closes this named capture group)

-[xyzw]{3} (?# Matches the remaining three characters in the swizzle, regardless of what they are)

If you wanted to match any combination of exactly four swizzle characters you would use "[xyzw]{4}", or
 you could use "[xyzw]+" to match one or more swizzle characters - but if I know there will be exactly four
 I prefer to make it exact. 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;regex example;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;depthbuffer      crosshair;;;;;;;;;;;;;;;;;
Oh, for anyone who is using my automatic crosshair code, 1.2.66/67 allows for an easier method 
to get the depth buffer that will probably work in many (but not all) games:
[ResourceDepthBuffer]
[ClearDepthStencilView]
ResourceDepthBuffer = ref this
 
that will set ResourceDepthBuffer to the most recent depth buffer the game cleared,
 which in a lot of cases will probably be one you want (this works in Hellblade), but it may not work in all games 
 (e.g. this might get you a shadow map in some games instead of the depth buffer). Depending on the bind flags of the depth
 buffer you may or may not need to perform a full copy to use that in a destination shader - if that is necessary 
 (or you aren't sure), I suggest using a second intermediate resource to limit the number of full copies, such as:

[ResourceDepthBufferRef]
[ResourceDepthBufferCopy]
max_copies_per_frame = 1

[ClearDepthStencilView]
ResourceDepthBufferRef = ref this

[ShaderOverrideHUD]

hash = ...
ResourceDepthBufferCopy = copy ResourceDepthBufferRef
vs-t100 = ref ResourceDepthBufferCopy
post vs-t100 = null 

;;;;;;;;;;;;;;;;;;;;;;;depthbuffer      crosshair;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;,steorize cubemaps;;;;;;;;;;;;
[TextureOverrideCubeMapReflections]
; Fixes broken environment mapped reflections
match_misc_flags = +texturecube
StereoMode = 2
;;;;;;;;;;;;;;;;;;;;,steorize cubemaps;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mouse;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
interesting example of the software mouse depth I could think of:
//float2 mouse_pos = (cursor_window / window_size * 2 - 1);
//output.pos.x += adjust_from_depth_buffer(mouse_pos.x, mouse_pos.y);
The mouse shader already has the mouse position and window size passed in (if you need this in another shader,
 use "cursor_x" and "cursor_y" instead as they have the "cursor_window / window_size" part pre-calculated and are already
 in the range 0:1 - you still need to multiply by 2 and subtract 1 to get them in the range -1:1 to use with a crosshair.hlsl,
 and in some games you may need to negate y).
Speaking of crosshair.hlsl, you will need to grab a copy that has been adapted to a given engine and #include it in the mouse shader.
 Grab it from Subnautica if you are using this on Unity 5.5+ (edit: you will need to delete the lines about "InWorldHUDZBuffer", as
 that is specific to that game), or Dreamfall Chapters for Unity 5.4 or older. If you need it for a different engine I might already
 have one ready to go, or if you feel up to it you can take a crack at adapting it yourself (can be pretty difficult - 
 if you don't get it exactly right the depth can be completely out of whack).
You will need to copy the depth buffer into the mouse shader - my Unity template should set up most of what you need already,
and so long as the game is using deferred lighting all you need to do is add these lines to the [CustomShaderSoftwareMouse] section:
vs-t110 = Resource_CameraDepthTexture
vs-cb13 = Resource_UnityPerCamera
post vs-t110 = null
post vs-cb13 = null


-------
[ResourceDepthBuffer]
[ClearDepthStencilView]
ResourceDepthBuffer = ref this
If using that, you may need to copy it to be able to use it in a destination shader (depends how the game set it up),
 but that's a framerate killer if you don't limit it and there are a lot of HUD elements it is being copied to.
 You can limit it by copying it only the first time it is used like this:
[ResourceDepthBufferRef]
[ResourceDepthBufferCopy]
max_copies_per_frame=1
[ClearDepthStencilView]
ResourceDepthBufferRef = ref this
reset_per_frame_limits = ResourceDepthBufferCopy
[ShaderOverrideHud]
; Or CustomShaderSoftwareMouse or wherever you need it
hash = ...
ResourceDepthBufferCopy = copy ResourceDepthBufferRef 
vs-t110 = ResourceDepthBufferCopy 
post vs-t110 = null

If you find the mouse is sitting behind a transparent object there is even a trick you can use to capture these and have it rest
 in front - that's what the "InWorldHUDZBuffer" was all about in the Subnautica version of crosshair.hlsl as well as the
 -[CustomShaderCaptureInWorldHUDDepth] and related sections in the d3dx.ini (this is used so the crosshair rests on the submarine
 HUD controls in that game). I also do something similar in Dreamfall Chapters to capture the depth of the Ghosts in the Dreamtime,
 but with a slightly different approach (either approach should have pretty much the same results. We didn't have
 support for clear= in 3DMigoto when I did DFC so I copied the regular depth buffer into the transparent depth buffer
 and used that in place of the original, whereas in Subnautica the transparent depth buffer only contains the relevant
 in-world HUD objects and nothing else, so both depth buffers are passed into crosshair.hlsl). 
 
 
 ----cursor color black------
 Chances are that mouse cursor is using an alpha channel and no mask - comment out these lines in mouse.hlsl draw_cursor_color:

// XXX: Subnautica: We have an alpha channel that is *NOT*
	// pre-multiplied (needs blend = ADD SRC_ALPHA INV_SRC_ALPHA), has
	// garbage in the transparent pixels and has and no mask to remove
	// them, so disable this:
        //if (!result.w)
        //      result.w = 1;
		
		

; Enable alpha blending for a colour cursor:
; XXX: Subnautica: Do not use pre-multiplied alpha!
;blend = ADD ONE INV_SRC_ALPHA
blend = ADD SRC_ALPHA INV_SRC_ALPHA

 ----cursor color black------


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mouse;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;texture dump;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
"dump" command
The "dump" command can be used in any command list to instantly dump an arbitrary resource when frame analysis is active,
optionally specifying analysis options specific to that resource. The filename will contain the ini section and resource name
 being dumped.

e.g. To collect HUD textures for filtering, instead of dumping all textures you can now dump only the textures
 in the HUD shader's t0 slot:

[ShaderOverrideHUD]
hash = xxxxxx
dump = mono dds deferred_ctx_accurate ps-t0

e.g. You can now dump custom resources:
[CustomShaderAutoConvergence]
...
dump = ResourceAutoConvergenceDepthDownscale128
dump = ResourceAutoConvergenceState
dump = ResourceAutoConvergence

e.g. You can now dump resources *before* the draw call, or at other specific times:
[CustomShaderCaptureInWorldHUDDepth]
depth_write_mask = all
..
dump = oD
oD = ResourceInWorldHUDDepth
dump = oD
draw = from_caller
dump = oD

;;;;;;;;;;;;;;;;;;;;;;;;;texture dump;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;HUD;;;;;;;;;;;;;;;;;;;;;
only stereoise the HUD when it is drawn to the screen (unless the off-screen render target was the same size as the resolution):

[ShaderOverrideCrosshair]
hash = f6870f9fe26b75c4
x3 = rt_width
y3 = rt_height
z3 = res_width
w3 = res_height

... vertex shader body ...

float4 rt_filter = IniParams.Load(int2(3, 0));
if (any(rt_filter.xy != rt_filter.zw))
	return;
	
... HUD adjustment ...
;;;;;;;;;;;;;;;;;;;;HUD;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;operators;;;;;;;;;;;;;;;;;;;;
Floating point values (Statically optimisable)
Ini params (x, y, z, w, x1, y1, ..., z7, w7)
Resource targets (ps-t0, vs-cb3, ib, vb0, oD, o0, etc), which will evaluate to the same meaning as
 for texture filtering (i.e. -0.0 if not bound, +0.0 if bound but no matching TextureOverride, +1.0 if matching TextureOverride
 with no filter_index, or the value of filter_index if it is set)
Any of the following keywords:

    rt_width - Active render target width
    rt_height - Active render target height
    res_width - Resolution width, as per get_resolution_from
    res_height - Resolution height, as per get_resolution_from
    window_width - Window width
    window_height - Window height
    vertex_count - Number of vertices being drawn, if applicable to the current draw call
    index_count - Number of indices being drawn, if applicable to the current draw call
    instance_count - Number of instances being drawn, if applicable to the current draw call
    cursor_showing - Indicates whether the mouse cursor is currently visible
    cursor_screen_x - Cursor position in absolute screen coordinates
    cursor_screen_y - Cursor position in absolute screen coordinates
    cursor_window_x - Cursor position relative to the window's client area in pixels
    cursor_window_y - Cursor position relative to the window's client area in pixels
    cursor_x - Cursor position relative to the window in the range 0 - 1 (recommended)
    cursor_y - Cursor position relative to the window in the range 0 - 1 (recommended)
    cursor_hotspot_x - hotspot coordinates in the cursor icon
    cursor_hotspot_y - hotspot coordinates in the cursor icon
    time - time since the application was launched in seconds
    scissor_left, scissor1_left, scissor2_left, ...
    scissor_top, ... - Coordinates of the scissor clipping rectangle
    scissor_right, ...
    scissor_bottom, ...
    raw_separation - Separation value in percents (not the same as the pre-calculated separation from StereoParams)
	(statically optimisable)
    eye_separation - IPD / screen width, as reported by the nvidia driver (statically optimisable)
    convergence - Same meaning as everywhere (statically optimisable)
    stereo_active - Indicates whether 3D Vision is currently enabled (statically optimisable)
    sli - Indicates whether SLI is currently enabled (statically optimisable)
	
These are all the currently supported operators, in order of highest to lowest precedence.
 Operators in the same level of precedence are parsed left to right or right to left as indicated below:

    Unary operators have the highest level of precedence and are parsed from right to left,
	but will not bind if there is an operand immediately to their left (as those cases are for the lower precedence
	addition and subtraction operators).

    ! Unary not
    - Unary minus/negation
    + Unary plus

    Right to left, e.g. 2**3**4 would evaluate as 2**(3**4). Using negative numbers or fractions should have the expected 
	mathematical outcomes.

    ** Exponentation

    Left to right. Dividing by zero will result in infinity (e.g. 1/0), negative infinity (e.g. 1/-0) or NaN (e.g. 0/0) - it will
	not result in an error.

    * Multiplication
    / Floating point division
    // Floor division (rounds towards negative infinity)
    % Floating point modulus

    Left to right

    + Addition
    - Subtraction

    Relational comparison operators. True evaluates to 1 and false evaluates to 0. These are parsed left to right
	and chaining these operators will follow C/HLSL style rules (e.g. (a < b < c) will evaluate as (1 < c) if a<b, or (0 < c) if a>=b, 
	as opposed to the mathematical meaning of ((a<b) && (b<c)).

    < Less than
    <= Less than or equal to
    > Greater than
    >= Greater than or equal to

    Comparison operators. We have some unique operators in this category not found in other programming languages
	(and not to be confused with operators in other languages that may look the same) - equality operators will
	consider +0.0 as being equal to -0.0, while the identical operators will consider these to be different
	(likewise NaN is never equal to NaN, but may be identical to another NaN of the same type, though the usual way
	to test for NaN is to test if it is not equal to itself). This is useful in the context of texture filtering,
	where negative zero indicates that no texture is bound to the slot in question, while positive zero indicates 
	that a texture was bound, but did not match any [TextureOverride] section, e.g. "if oD !== -0.0" can be used to
	determine if a depth buffer is bound. These are parsed left to right.

    == Equality
    != Inequality
    === Identical
    !== Not-identical

    These will evaluate to 1 for true or 0 for false and are parsed from left to right. Both sides of the expression
	will always be evaluated, though since expressions currently do not have side-effects this is inconsequential.

    && Logical and

    These will evaluate to 1 for true or 0 for false and are parsed from left to right.
	Both sides of the expression will always be evaluated, though since expressions currently do not have side-effects
	this is inconsequential.

    || Logical or

There are no assignment operators in the expression evaluator - assignments are handled separately using the existing constructs.

;;;;;;;;;;;;;;;;;operators;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;frustum culling;;;;;;;;;;;;;;;;;;
separation = StereoParams.Load(0).x;
o0.x = o0.x * (1 + separation);
;;;;;;;;;;;;;;;;;;frustum culling;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;; o0.w = 1 ;;;;;;;;;;;; screen depth

Best bet would be to test the w component of the position, which will be equal to 1 at screen depth,

;;;;;;;;;;;;;;;;;;;;;;; o0.w = 1 ;;;;;;;;;;;; screen depth

;;;;;;;;;;;;;;;;;where to adjust ;;;;;;;;;;;;;;;;;;
Sure, let's take a look at the shader and I'll point out what I look for in this pattern:
...
    preshader
    rcp c0.x, c2.x
    neg r0.x, c2.z
...
Remove or comment out this preshader section to make sure it will work with Helix Mod.
vs_3_0
...
    dcl_position v0
    dcl_position o0
Note which output register is the position, in this case o0. Let's look for where it's used...
...
    dp4 r1.x, r2, c11
    dp4 r1.y, r2, c12
    dp4 r1.z, r2, c13
    dp4 r1.w, r2, c14
    mov o0, r1
Here we see that the output position is set from a temporary register r1. The output position will be adjusted automatically
 by the driver, but if anything else in this shader uses r1 it will likely need to be adjusted.
 This would be a good spot to insert the prime directive on r1 so any more uses below this point get the adjusted version as well.
...
    mov r3.zw, r1
Here we see r1 is used again, but as this only uses the Z and W components it won't matter since we only adjust X. 
Let's keep looking...
...
    dp3 r1.z, r2, v0
This line replaced r1.z with something else. Still not interesting, let's keep looking...
...
    mul r4, r1.xwwy, c26.yyzw
Ah ha! This line is using the X component of r1, so it needs to be adjusted before this point. 

;;;;;;;;;;;;;;;;;where to adjust ;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;; StereoFlagsDX10 ;;;;;;;;;;;;;;;;;;;;;;;;; 

StereoTextureEnable = 0x00000023
StereoFlagsDX10 = 0x00001008
				  0x00004008
				  0x00005008
				  0x00008008
				  
;;;;;;;;;;;;;;;;;;;;;;;; StereoFlagsDX10 ;;;;;;;;;;;;;;;;;;;;;;;;; 



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,explication;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;fix
// This looks like Clip coord
  r0.xy = v0.xy / back_buffer_size.xy; 
// This one is using the depth buffer to get the position in View Space
  r1.xyzw = __tex_linear_depth.Sample(__samp_linear_depth_s, r0.xy).xyzw; 
// Here is were we need to correct the position
//CASE A:
  vec4 temp = r1;
  temp = temp * camera_projection; // operation might be the other way
  temp.x += separation * (vPos.w - g_convergence) * camera_projection.m00;
  temp = temp * camera_inv_projection; // operation might be the other way
//CASE B:
	r1.x -= separation * (vPos.w - g_convergence) / camera_projection.m00;
  
// This is a standard divide of all components by the w component "to scale" it correctly
  r1.yzw = v1.xyz / v1.www;
  r1.xyz = r1.yzw * r1.xxx + camera_pos.xyz;
  
  
Now, basically you need to experiment a bit and see what actually fits and works.
 (by changing the operation order, addition/division).
Also, sometimes you need to use this variant of the formula (notice the minus):
vPos += separation * -(vPos.w - g_convergence);

vPos.w might not always be availalbe is vPos is a vec3, in which case you can use the .z component).
Basically now you need to experiment a bit and see what works on a particular game;))


To clarify, we can adjust a coordinate either in "view space" or "projection space" (AKA "clip space").
 These are similar coordinate systems as they are both relative to the camera, but they aren't quite the same thing 
 and the differences can be confusing.

A coordinate typically undergoes several transformations to get it to the screen. Depending on the game,
 several of these steps will often be combined (e.g. in a world-view-projection matrix):

    local space coordinate * world matrix = world space coordinate
    world space coordinate - camera position = world space coordinate (relative to camera)
    world space coordinate about camera * view matrix = view space coordinate
    view space coordinate * projection matrix = projection / clip space coordinate
    projection space coordinate / w = screen space coordinate between -1 and 1
    (screen space coordinate / 2 + 0.5) * resolution = pixel
	
	
void main( 
  float4 v0 : POSITION0,
// This shader has two outputs. o0 is always in "clip space" since it is the
// position output, but the game could do whatever it likes with the texcoord:
  out float4 o0 : SV_POSITION0,
  out float4 o1 : TEXCOORD1)
{
  float4 r0,r1;
  uint4 bitmask, uiDest;
  float4 fDest;
  r0.xyz = light_proxy_scale.xyz * v0.xyz;
  r0.w = 1;
// r1 and o0 are using the world_view_proj matrix, so they will both be in
// "clip space" (AKA "projection space", similar to but not quite the same as
// "screen coordinates") after this:
  r1.x = dot(r0.xyzw, world_view_proj._m00_m10_m20_m30);
  r1.y = dot(r0.xyzw, world_view_proj._m01_m11_m21_m31);
  r1.z = dot(r0.xyzw, world_view_proj._m02_m12_m22_m32);
  r1.w = dot(r0.xyzw, world_view_proj._m03_m13_m23_m33);
  o0.xyzw = r1.xyzw;
// the clip space coordinates are now being multiplied by the inverse
// projection matrix, which will make r0 "view space" after this:
  r0.x = dot(r1.xyzw, camera_inv_projection._m00_m10_m20_m30);
  r0.y = dot(r1.xyzw, camera_inv_projection._m01_m11_m21_m31);
  r0.z = dot(r1.xyzw, camera_inv_projection._m02_m12_m22_m32);
// And now the "view space" coordinates are being multiplied by the inverse
// view matrix. This will most likely mean that the result is in "world space"
// coordinates, but you cannot be sure if it is relative to the camera
// (likely), or a fixed point in the world. I also note that the homogeneous W
// coordinate is being set to the same value as the output position depth,
// which is a bit unusual, but suggests that that the world coordinate has not
// yet been normalised into a Cartesian coordinate:
  o1.w = r1.w;
  o1.x = dot(r0.xyz, camera_inv_view._m00_m10_m20);
  o1.y = dot(r0.xyz, camera_inv_view._m01_m11_m21);
  o1.z = dot(r0.xyz, camera_inv_view._m02_m12_m22);
  return;
}
  
  
  //Inn - broken window lighting
<snip>
void main( 
// v1 is the un-normalised world space coordinate passed from the vertex
// shader:
  float4 v0 : SV_POSITION0,
  float4 v1 : TEXCOORD1,
  out float4 o0 : SV_TARGET0)
{
  float4 r0,r1,r2,r3,r4,r5,r6,r7;
  uint4 bitmask, uiDest;
  float4 fDest;
  r0.xy = v0.xy / back_buffer_size.xy;
// This is something you will almost always want to look for in a shadow shader
// - where the depth information is sampled. One thing to note here is that
// this texture name indicates that it contains the LINEAR DEPTH. This game is
// really making things easy for you - that means you don't need to worry about
// scaling a value from the Z Buffer (0-1) to world depth scale (which the game
// would typically do at this point, but you would have to recognise which
// instructions are relevant to it).
// The linear depth will usually be in r1.x (you can look at which is used in
// the multiply below to check). The y, z and w parameters will be meaningless.
  r1.xyzw = __tex_linear_depth.Sample(__samp_linear_depth_s, r0.xy).xyzw;
// As we noted above, the world coordinates were not normalised in the vertex
// shader - this line is normalising them:
  r1.yzw = v1.xyz / v1.www;
// This is another line that you will almost always need to find in a shadow
// shader - specifically you are looking for the line that multiplies the depth
// value (in r1.x) by some coordinate. In this case we know from looking at the
// vertex shader that the coordinate is in "world space", and afterwards it
// adds the coordinates of the camera position, which indicates that the world
// space coordinate in r1.yzw is centered around the camera.
  r1.xyz = r1.yzw * r1.xxx + camera_pos.xyz;
  
Depending on what coordinate system you are currently in you will need to do one of several options:

    Projection/Clip space:
        Subtract usual stereo formula


    View Space:
        Option 1: Subtract usual stereo formula multiplied by camera_inv_projection._m00
        Option 2: Subtract usual stereo formula divided by camera_projection._m00
        Option 3: Convert to projection space, subtract usual formula, convert back to view space
        Option 4: Convert correction value based on depth alone to view-space then subtract it from the coordinate (may produce more accurate results than option 3 in some cases)


    World Space:
        Option 1: Convert to either view or projection space, see above, convert back to world space
        Option 2: Convert correction value based on depth alone to world-space then subtract it from the coordinate (may produce more accurate results in some cases)


<snip>
  r1.z = dot(r0.xyzw, world_view_proj._m02_m12_m22_m32);
  r1.w = dot(r0.xyzw, world_view_proj._m03_m13_m23_m33);
  o0.xyzw = r1.xyzw;
// You may or may not need to stereo correct r1 at this point. If the driver is
// correcting o0 (e.g. in-world light like a point or spot light) you will need
// to so that it matches, otherwise you should not (e.g. full-screen
// directional lighting pass). Try it and see, but be aware that it might
// interact with the correction in the pixel shader:
float4 stereo = StereoParams.Load(0);
r1.x += stereo.x * (r1.w - stereo.y);
  r0.x = dot(r1.xyzw, camera_inv_projection._m00_m10_m20_m30);
  r0.y = dot(r1.xyzw, camera_inv_projection._m01_m11_m21_m31);
<snip>


<snip>
// We need to apply the correction in the *middle* of this instruction before
// adding the camera position, so split it into two separate instructions:
  // r1.xyz = r1.yzw * r1.xxx + camera_pos.xyz;
  r1.xyz = r1.yzw * r1.xxx;
// We have a coordinate in world-space relative to the camera. We convert this
// into projection-space, apply the correction, then convert it back (there are
// some alternative variations that may work as well, such as only converting
// to view-space instead of projection-space and using the view-space formula, or
// since we already have the linear depth just convert float4(separation * (depth
// - convergence), 0, 0, 1) to world-space and subtract that from r1 (which may
// help if you find this produces flickering, or just slightly inaccurate shadows).
float4 stereo = StereoParams.Load(0);
float4 tmp;
tmp = mul(camera_view, float4(r1.xyz, 1)); // If 1 doesn't work, try 0
tmp = mul(camera_projection, tmp);
tmp = tmp / tmp.w; // May or may not be necessary
tmp.x -= stereo.x * (tmp.z - stereo.y);
tmp = mul(camera_inv_projection, tmp);
tmp = mul(camera_inv_view, tmp);
r1.xyz = tmp.xyz / tmp.w; // May or may not be necessary
// This is the final part of the original instruction we split up:
  r1.xyz = r1.xyz + camera_pos.xyz;
<snip>



As a general rule of thumb, if the adjustment is in the vertex shader you are probably adding,
 if it's in the pixel shader you are probably subtracting... But of course that can vary as well.
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,explication;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;fix
  
  
  ;;;;;;;;;;;;;;;;;calculate FOV;;;;;;;;;;;;;;;;;;;;;;;
  PS
  
  float fov = cb0[69].x*cb0[69].x+cb0[70].x*cb0[70].x+cb0[71].x*cb0[71].x;
  o5.x+=stereo.x*stereo.y*cb0[69].x/fov;
  o5.y+=stereo.x*stereo.y*cb0[70].x/fov;
  o5.z+=stereo.x*stereo.y*cb0[71].x/fov;
  
  
  VS
  
  r0.xyzw = cb1[1].xyzw * v0.yyyy;
  r0.xyzw = cb1[0].xyzw * v0.xxxx + r0.xyzw;
  r0.xyzw = cb1[2].xyzw * v0.zzzz + r0.xyzw;
  r1.xyzw = cb1[3].xyzw + r0.xyzw;
  r0.xyz = cb1[3].xyz * v0.www + r0.xyz;
  r2.xyzw = cb0[70].xyzw * r1.yyyy;
  r2.xyzw = cb0[69].xyzw * r1.xxxx + r2.xyzw;
  r2.xyzw = cb0[71].xyzw * r1.zzzz + r2.xyzw;
  o0.xyzw = cb0[72].xyzw * r1.wwww + r2.xyzw;
  o1.xy = v2.xy * cb3[1].xy + cb3[1].zw;
  p1.x = 0;
  r1.x = dot(v1.xyz, cb1[4].xyz);
  r1.y = dot(v1.xyz, cb1[5].xyz);
  r1.z = dot(v1.xyz, cb1[6].xyz);
  r0.w = dot(r1.xyz, r1.xyz);
  r0.w = max(1.17549435e-38, r0.w);
  r0.w = rsqrt(r0.w);
  o2.xyz = r1.xyz * r0.www;
  o3.xyz = r0.xyz;
  
  //float fov = cb1[0].x*cb1[0].x+cb1[1].x*cb1[1].x+cb1[2].x*cb1[2].x;
  //o3.x+=stereo.x*stereo.y*cb1[0].x/fov;
  //o3.y+=stereo.x*stereo.y*cb1[1].x/fov;
  //o3.z+=stereo.x*stereo.y*cb1[2].x/fov;
  
  r1.xyz = cb2[1].xyz * r0.yyy;
  r0.xyw = cb2[0].xyz * r0.xxx + r1.xyz;
  r0.xyz = cb2[2].xyz * r0.zzz + r0.xyw;
  o4.xyz = cb2[3].xyz + r0.xyz;
  o4.w = 0;
  return;
}
  
  
  

  
  
  //Geometry VS 1. Always stereoized in ShaderFixesDM.
// ---- Created with geo-11 v0.6.193 on Tue Apr 30 18:45:18 2024
cbuffer cb3 : register(b3)
{
  float4 cb3[2];
}

cbuffer cb2 : register(b2)
{
  float4 cb2[25];
}

cbuffer cb1 : register(b1)
{
  float4 cb1[7];
}

cbuffer cb0 : register(b0)
{
  float4 cb0[73];
}




// 3Dmigoto declarations
#define cmp -
Texture1D<float4> IniParams : register(t120);
Texture2D<float4> StereoParams : register(t125);


void main(
  float4 v0 : POSITION0,
  float3 v1 : NORMAL0,
  float2 v2 : TEXCOORD0,
  out float4 o0 : SV_POSITION0,
  out float2 o1 : TEXCOORD0,
  out float p1 : TEXCOORD4,
  out float4 o2 : TEXCOORD1,
  out float4 o3 : TEXCOORD2,
  out float4 o4 : TEXCOORD3)
{
  float4 r0,r1,r2;
  uint4 bitmask, uiDest;
  float4 fDest;
  
  float4 stereo = StereoParams.Load(0);
  
  r0.xyzw = cb1[1].xyzw * v0.yyyy;
  r0.xyzw = cb1[0].xyzw * v0.xxxx + r0.xyzw;
  r0.xyzw = cb1[2].xyzw * v0.zzzz + r0.xyzw;
  r1.xyzw = cb1[3].xyzw + r0.xyzw;
  r0.xyz = cb1[3].xyz * v0.www + r0.xyz;
  r2.xyzw = cb0[70].xyzw * r1.yyyy;
  r2.xyzw = cb0[69].xyzw * r1.xxxx + r2.xyzw;
  r2.xyzw = cb0[71].xyzw * r1.zzzz + r2.xyzw;
  o0.xyzw = cb0[72].xyzw * r1.wwww + r2.xyzw;
  o1.xy = v2.xy * cb3[1].xy + cb3[1].zw;
  p1.x = 0;
  r1.x = dot(v1.xyz, cb1[4].xyz);
  r1.y = dot(v1.xyz, cb1[5].xyz);
  r1.z = dot(v1.xyz, cb1[6].xyz);
  r0.w = dot(r1.xyz, r1.xyz);
  r0.w = max(1.17549435e-38, r0.w);
  r0.w = rsqrt(r0.w);
  o2.xyz = r1.xyz * r0.www;
  o3.xyz = r0.xyz;
  
  //float fov = cb1[0].x*cb1[0].x+cb1[1].x*cb1[1].x+cb1[2].x*cb1[2].x;
  //o3.x+=stereo.x*stereo.y*cb1[0].x/fov;
  //o3.y+=stereo.x*stereo.y*cb1[1].x/fov;
  //o3.z+=stereo.x*stereo.y*cb1[2].x/fov;
  
  r1.xyz = -cb2[20].xyz + r0.xyz;
  r1.x = dot(r1.xyz, r1.xyz);
  r2.xyz = -cb2[21].xyz + r0.xyz;
  r1.y = dot(r2.xyz, r2.xyz);
  r2.xyz = -cb2[22].xyz + r0.xyz;
  r1.z = dot(r2.xyz, r2.xyz);
  r2.xyz = -cb2[23].xyz + r0.xyz;
  r1.w = dot(r2.xyz, r2.xyz);
  r1.xyzw = cmp(r1.xyzw < cb2[24].xyzw);
  r2.xyz = r1.xyz ? float3(-1,-1,-1) : float3(-0,-0,-0);
  r1.xyzw = r1.xyzw ? float4(1,1,1,1) : 0;
  r2.xyz = r1.yzw + r2.xyz;
  r1.yzw = max(float3(0,0,0), r2.xyz);
  r0.w = dot(r1.xyzw, float4(4,3,2,1));
  r0.w = 4 + -r0.w;
  r1.x = (uint)r0.w;
  o4.w = r0.w;
  r0.w = (uint)r1.x << 2;
  r1.xyz = cb2[r0.w+1].xyz * r0.yyy;
  r1.xyz = cb2[r0.w+0].xyz * r0.xxx + r1.xyz;
  r0.xyz = cb2[r0.w+2].xyz * r0.zzz + r1.xyz;
  o4.xyz = cb2[r0.w+3].xyz + r0.xyz;
  return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//   using 3Dmigoto v0.6.193 on Tue Apr 30 18:45:18 2024
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// POSITION                 0   xyzw        0     NONE   float   xyzw
// NORMAL                   0   xyz         1     NONE   float   xyz
// TEXCOORD                 0   xy          2     NONE   float   xy
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float   xyzw
// TEXCOORD                 0   xy          1     NONE   float   xy
// TEXCOORD                 4     z         1     NONE   float     z
// TEXCOORD                 1   xyz         2     NONE   float   xyz
// TEXCOORD                 2   xyz         3     NONE   float   xyz
// TEXCOORD                 3   xyzw        4     NONE   float   xyzw
//
vs_4_0
dcl_constantbuffer CB0[73], immediateIndexed
dcl_constantbuffer CB1[7], immediateIndexed
dcl_constantbuffer CB2[25], dynamicIndexed
dcl_constantbuffer CB3[2], immediateIndexed
dcl_input v0.xyzw
dcl_input v1.xyz
dcl_input v2.xy
dcl_output_siv o0.xyzw, position
dcl_output o1.xy
dcl_output o1.z
dcl_output o2.xyz
dcl_output o3.xyz
dcl_output o4.xyzw
dcl_temps 3
mul r0.xyzw, v0.yyyy, cb1[1].xyzw
mad r0.xyzw, cb1[0].xyzw, v0.xxxx, r0.xyzw
mad r0.xyzw, cb1[2].xyzw, v0.zzzz, r0.xyzw
add r1.xyzw, r0.xyzw, cb1[3].xyzw
mad r0.xyz, cb1[3].xyzx, v0.wwww, r0.xyzx
mul r2.xyzw, r1.yyyy, cb0[70].xyzw
mad r2.xyzw, cb0[69].xyzw, r1.xxxx, r2.xyzw
mad r2.xyzw, cb0[71].xyzw, r1.zzzz, r2.xyzw
mad o0.xyzw, cb0[72].xyzw, r1.wwww, r2.xyzw
mad o1.xy, v2.xyxx, cb3[1].xyxx, cb3[1].zwzz
mov o1.z, l(0)
dp3 r1.x, v1.xyzx, cb1[4].xyzx
dp3 r1.y, v1.xyzx, cb1[5].xyzx
dp3 r1.z, v1.xyzx, cb1[6].xyzx
dp3 r0.w, r1.xyzx, r1.xyzx
max r0.w, r0.w, l(1.175494351E-38)
rsq r0.w, r0.w
mul o2.xyz, r0.wwww, r1.xyzx
mov o3.xyz, r0.xyzx
add r1.xyz, r0.xyzx, -cb2[20].xyzx
dp3 r1.x, r1.xyzx, r1.xyzx
add r2.xyz, r0.xyzx, -cb2[21].xyzx
dp3 r1.y, r2.xyzx, r2.xyzx
add r2.xyz, r0.xyzx, -cb2[22].xyzx
dp3 r1.z, r2.xyzx, r2.xyzx
add r2.xyz, r0.xyzx, -cb2[23].xyzx
dp3 r1.w, r2.xyzx, r2.xyzx
lt r1.xyzw, r1.xyzw, cb2[24].xyzw
movc r2.xyz, r1.xyzx, l(-1.000000,-1.000000,-1.000000,0), l(-0.000000,-0.000000,-0.000000,0)
and r1.xyzw, r1.xyzw, l(0x3f800000, 0x3f800000, 0x3f800000, 0x3f800000)
add r2.xyz, r2.xyzx, r1.yzwy
max r1.yzw, r2.xxyz, l(0.000000, 0.000000, 0.000000, 0.000000)
dp4 r0.w, r1.xyzw, l(4.000000, 3.000000, 2.000000, 1.000000)
add r0.w, -r0.w, l(4.000000)
ftou r1.x, r0.w
mov o4.w, r0.w
ishl r0.w, r1.x, l(2)
mul r1.xyz, r0.yyyy, cb2[r0.w + 1].xyzx
mad r1.xyz, cb2[r0.w + 0].xyzx, r0.xxxx, r1.xyzx
mad r0.xyz, cb2[r0.w + 2].xyzx, r0.zzzz, r1.xyzx
add o4.xyz, r0.xyzx, cb2[r0.w + 3].xyzx
ret
// Approximately 0 instruction slots used

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/


//Specular reflections VS. Underground cave abyss.
// ---- Created with geo-11 v0.6.193 on Sat May 11 19:21:38 2024
cbuffer cb2 : register(b2)
{
  float4 cb2[23];
}

cbuffer cb1 : register(b1)
{
  float4 cb1[16];
}

cbuffer cb0 : register(b0)
{
  float4 cb0[73];
}




// 3Dmigoto declarations
#define cmp -
Texture1D<float4> IniParams : register(t120);
Texture2D<float4> StereoParams : register(t125);


void main(
  float4 v0 : POSITION0,
  float3 v1 : NORMAL0,
  float2 v2 : TEXCOORD0,
  out float4 o0 : TEXCOORD0,
  out float4 o1 : TEXCOORD1,
  out float4 o2 : TEXCOORD2,
  out float4 o3 : TEXCOORD3,
  out float4 o4 : TEXCOORD4,
  out float4 o5 : TEXCOORD5,
  out float4 o6 : TEXCOORD6,
  out float3 o7 : TEXCOORD7,
  out float4 o8 : SV_POSITION0)
{
  float4 r0,r1;
  uint4 bitmask, uiDest;
  float4 fDest;
  
  float4 stereo = StereoParams.Load(0);
  
  o0.zw = v2.xy * cb1[15].xy + cb1[15].zw;
  o0.xy = v2.xy;
  o1.xy = v2.xy * cb2[19].xy + cb2[19].zw;
  o1.zw = v2.xy * cb2[20].xy + cb2[20].zw;
  o2.xy = v2.xy * cb2[21].xy + cb2[21].zw;
  o2.zw = v2.xy * cb2[22].xy + cb2[22].zw;
  r0.xyz = cb1[1].xyz * v1.yyy;
  r0.xyz = cb1[0].xyz * v1.xxx + r0.xyz;
  r0.xyz = cb1[2].xyz * v1.zzz + r0.xyz;
  r0.w = dot(r0.xyz, r0.xyz);
  r0.w = max(1.17549435e-38, r0.w);
  r0.w = rsqrt(r0.w);
  o3.xyz = r0.xyz * r0.www;
  r0.xy = float2(1,0) * v1.yz;
  r0.xy = v1.zx * float2(0,1) + -r0.xy;
  r0.yzw = cb1[1].xyz * r0.yyy;
  r0.xyz = cb1[0].xyz * r0.xxx + r0.yzw;
  r0.w = dot(r0.xyz, r0.xyz);
  r0.w = max(1.17549435e-38, r0.w);
  r0.w = rsqrt(r0.w);
  r0.xyz = r0.xyz * r0.www;
  o4.xyz = -r0.xyz;
  r0.x = cmp(cb1[9].w >= 0);
  o4.w = r0.x ? 1 : -1;
  r0.xyz = cb1[1].xyz * v0.yyy;
  r0.xyz = cb1[0].xyz * v0.xxx + r0.xyz;
  r0.xyz = cb1[2].xyz * v0.zzz + r0.xyz;
  r0.xyz = cb1[3].xyz + r0.xyz;
  o5.xyz = cb0[13].xyz + -r0.xyz;
  
  float fov = cb0[69].x*cb0[69].x+cb0[70].x*cb0[70].x+cb0[71].x*cb0[71].x;
  o5.x+=stereo.x*stereo.y*cb0[69].x/fov;
  o5.y+=stereo.x*stereo.y*cb0[70].x/fov;
  o5.z+=stereo.x*stereo.y*cb0[71].x/fov;
  
  r1.xyzw = cb0[70].xyzw * r0.yyyy;
  r1.xyzw = cb0[69].xyzw * r0.xxxx + r1.xyzw;
  r1.xyzw = cb0[71].xyzw * r0.zzzz + r1.xyzw;
  o7.xyz = r0.xyz;
  r0.xyzw = cb0[72].xyzw + r1.xyzw;
  r1.x = r0.z / cb0[14].y;
  o8.xyzw = r0.xyzw;
  r0.x = 1 + -r1.x;
  r0.x = cb0[14].z * r0.x;
  r0.x = max(0, r0.x);
  o6.x = cb0[51].x * r0.x;
  o6.yzw = float3(0,0,0);
  return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//   using 3Dmigoto v0.6.193 on Sat May 11 19:21:38 2024
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// POSITION                 0   xyzw        0     NONE   float   xyz
// NORMAL                   0   xyz         1     NONE   float   xyz
// TEXCOORD                 0   xy          2     NONE   float   xy
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// TEXCOORD                 0   xyzw        0     NONE   float   xyzw
// TEXCOORD                 1   xyzw        1     NONE   float   xyzw
// TEXCOORD                 2   xyzw        2     NONE   float   xyzw
// TEXCOORD                 3   xyz         3     NONE   float   xyz
// TEXCOORD                 4   xyzw        4     NONE   float   xyzw
// TEXCOORD                 5   xyz         5     NONE   float   xyz
// TEXCOORD                 6   xyzw        6     NONE   float   xyzw
// TEXCOORD                 7   xyz         7     NONE   float   xyz
// SV_POSITION              0   xyzw        8      POS   float   xyzw
//
vs_4_0
dcl_constantbuffer CB0[73], immediateIndexed
dcl_constantbuffer CB1[16], immediateIndexed
dcl_constantbuffer CB2[23], immediateIndexed
dcl_input v0.xyz
dcl_input v1.xyz
dcl_input v2.xy
dcl_output o0.xyzw
dcl_output o1.xyzw
dcl_output o2.xyzw
dcl_output o3.xyz
dcl_output o4.xyzw
dcl_output o5.xyz
dcl_output o6.xyzw
dcl_output o7.xyz
dcl_output_siv o8.xyzw, position
dcl_temps 2
mad o0.zw, v2.xxxy, cb1[15].xxxy, cb1[15].zzzw
mov o0.xy, v2.xyxx
mad o1.xy, v2.xyxx, cb2[19].xyxx, cb2[19].zwzz
mad o1.zw, v2.xxxy, cb2[20].xxxy, cb2[20].zzzw
mad o2.xy, v2.xyxx, cb2[21].xyxx, cb2[21].zwzz
mad o2.zw, v2.xxxy, cb2[22].xxxy, cb2[22].zzzw
mul r0.xyz, v1.yyyy, cb1[1].xyzx
mad r0.xyz, cb1[0].xyzx, v1.xxxx, r0.xyzx
mad r0.xyz, cb1[2].xyzx, v1.zzzz, r0.xyzx
dp3 r0.w, r0.xyzx, r0.xyzx
max r0.w, r0.w, l(1.175494351E-38)
rsq r0.w, r0.w
mul o3.xyz, r0.wwww, r0.xyzx
mul r0.xy, v1.yzyy, l(1.000000, 0.000000, 0.000000, 0.000000)
mad r0.xy, v1.zxzz, l(0.000000, 1.000000, 0.000000, 0.000000), -r0.xyxx
mul r0.yzw, r0.yyyy, cb1[1].xxyz
mad r0.xyz, cb1[0].xyzx, r0.xxxx, r0.yzwy
dp3 r0.w, r0.xyzx, r0.xyzx
max r0.w, r0.w, l(1.175494351E-38)
rsq r0.w, r0.w
mul r0.xyz, r0.wwww, r0.xyzx
mov o4.xyz, -r0.xyzx
ge r0.x, cb1[9].w, l(0.000000)
movc o4.w, r0.x, l(1.000000), l(-1.000000)
mul r0.xyz, v0.yyyy, cb1[1].xyzx
mad r0.xyz, cb1[0].xyzx, v0.xxxx, r0.xyzx
mad r0.xyz, cb1[2].xyzx, v0.zzzz, r0.xyzx
add r0.xyz, r0.xyzx, cb1[3].xyzx
add o5.xyz, -r0.xyzx, cb0[13].xyzx
mul r1.xyzw, r0.yyyy, cb0[70].xyzw
mad r1.xyzw, cb0[69].xyzw, r0.xxxx, r1.xyzw
mad r1.xyzw, cb0[71].xyzw, r0.zzzz, r1.xyzw
mov o7.xyz, r0.xyzx
add r0.xyzw, r1.xyzw, cb0[72].xyzw
div r1.x, r0.z, cb0[14].y
mov o8.xyzw, r0.xyzw
add r0.x, -r1.x, l(1.000000)
mul r0.x, r0.x, cb0[14].z
max r0.x, r0.x, l(0.000000)
mul o6.x, r0.x, cb0[51].x
mov o6.yzw, l(0,0,0,0)
ret
// Approximately 0 instruction slots used

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

  ;;;;;;;;;;;;;;;;;calculate FOV;;;;;;;;;;;;;;;;;;;;;;;
  
  
;;;;;;;;;;;;;;;;;;;;Help on screen TXT;;;;;;;;;;;;;;;;;;;;;;  
[Key_ShortCycle_depth_Crosshair_Icons]
Key = no_modifiers 7
type = cycle
x = 0.7, 0.90, 1.015
run = CommandListQuickCrossHairDepth1, CommandListQuickCrossHairDepth2, CommandListQuickCrossHairDepth3,
	[CommandListQuickCrossHairDepth1]
	Resource\ShaderFixes\help.ini\Notification = ref Resource3DPower1
	run = CustomShader\ShaderFixes\help.ini\FormatText
	$\ShaderFixes\help.ini\notification_timeout = time + 3.0
	[CommandListQuickCrossHairDepth2]
	Resource\ShaderFixes\help.ini\Notification = ref Resource3DPower2
	run = CustomShader\ShaderFixes\help.ini\FormatText
	$\ShaderFixes\help.ini\notification_timeout = time + 3.0
	[CommandListQuickCrossHairDepth3]
	Resource\ShaderFixes\help.ini\Notification = ref Resource3DPower3
	run = CustomShader\ShaderFixes\help.ini\FormatText
	$\ShaderFixes\help.ini\notification_timeout = time + 3.0
	[Resource3DPower1]
	type = Buffer
	data = "CrossHair Depth: 70%"
	[Resource3DPower2]
	type = Buffer
	data = "CrossHair Depth: 90%"
	[Resource3DPower3]
	type = Buffer
	data = "CrossHair Depth: 100%"
  [Key_ShortCycle_depth_Crosshair_Icons]
Key = no_modifiers 7
type = cycle
x = 0.7, 0.90, 1.015
run = CommandListQuickCrossHairDepth1, CommandListQuickCrossHairDepth2, CommandListQuickCrossHairDepth3,
	[CommandListQuickCrossHairDepth1]
	Resource\ShaderFixes\help.ini\Notification = ref Resource3DPower1
	run = CustomShader\ShaderFixes\help.ini\FormatText
	$\ShaderFixes\help.ini\notification_timeout = time + 3.0
	[CommandListQuickCrossHairDepth2]
	Resource\ShaderFixes\help.ini\Notification = ref Resource3DPower2
	run = CustomShader\ShaderFixes\help.ini\FormatText
	$\ShaderFixes\help.ini\notification_timeout = time + 3.0
	[CommandListQuickCrossHairDepth3]
	Resource\ShaderFixes\help.ini\Notification = ref Resource3DPower3
	run = CustomShader\ShaderFixes\help.ini\FormatText
	$\ShaderFixes\help.ini\notification_timeout = time + 3.0
	[Resource3DPower1]
	type = Buffer
	data = "CrossHair Depth: 70%"
	[Resource3DPower2]
	type = Buffer
	data = "CrossHair Depth: 90%"
	[Resource3DPower3]
	type = Buffer
	data = "CrossHair Depth: 100%"
	
	
include = ShaderFixes\help.ini


	
;;;;;;;;;;;;;;;;;;;;Help on screen TXT;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;one eye monoize;;;;;;;;;;;;;;;;;;;
hash buffers etc.... one eye
StereoMode = 2

hash buffers etc.... mono to stereo
StereoMode = 1

[ShaderOverrideSparksVS2]
Hash = 1c5e2051dd8a127e
vs-t0 = mono copy vs-t0


Search "stride" in shaderusage to find buffers and fix one eye
;;;;;;;;;;;;;;;;;;;;;;;;one eye monoize;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;steorize;;;;;;;;;;;;

  r1.x-=stereo.x;
  
  r2.xyzw = cb0[330].xyzw * r1.yyyy;
  r1.xyzw = cb0[329].xyzw * r1.xxxx + r2.xyzw;
  r1.xyzw = cb0[331].xyzw + r1.xyzw;
  r1.xyzw = cb0[332].xyzw + r1.xyzw;
  
  r7.x+=stereo.x*stereo.y*cb0[329].x*cb13[9].x;
  r7.y+=stereo.x*stereo.y*cb0[329].x*cb13[10].x;
  r7.z+=stereo.x*stereo.y*cb0[329].x*cb13[11].x;
  
  
;;;;;;;;;;steorize;;;;;;;;;;;;

;;;;;;;;;;fix in PS;;;;;;;;;;;;
  
[ShaderOverrideVignettePS1]
Hash = d36c2694b245595b
x8 = rt_width
y8 = rt_height
  
  
v2.x-=stereo.x*iniparams8.x/iniparams8.y;
r0.x = dot(v2.xy, v2.xy);

;;;;;;;;;;fix in PS;;;;;;;;;;;;

;;;;;;otras formulas;;;;;;;;;;;;;;;;;;;;;;

r4.x+=s.x*(r1.w*s.y-1);


r21.x-=stereo.x*(1-stereo.y/v0.w)*0.5;
;;;;;;otras formulas;;;;;;;;;;;;;;;;;;;;;;

;;;;convergence scaling
o0.x+=stereo.x*stereo.y*0.9;
;;;;convergence scaling

;;;;;;; regex repeat pattern ;;;;;;;;
(?P<SwizzW1>[xyzw])(?P=SwizzW1)(?P=SwizzW1)(?P=SwizzW1)    --> wwww
;;;;;;; regex repeat pattern ;;;;;;;;




	
